OS 정리 6
========

Chapter 3 - Process
--------------

### Operations of Processes

대부분의 프로세스들은 병행 실행될 수 있으며, 동적으로 생성되고 제거될 수 있다.

* `Process Creation` 프로세스 생성
* `Process Termination` 프로세스 제거



#### Process Creation

* `Parent process` 는 `children processes` 를 생성하고, 이 각각의 프로세스들은 다시 다른 프로세스를 생성할 수 있어서, 그 결과 `a tree of process` 를 형성한다.
  * 프로세스 생성 system-call을 사용해서 이를 수행한다.
  * 왜 이런식으로 만드는가? single 프로세스를 만드는것보다 부모 프로세스 내의 children이 서로 도와서 작동하도록 만드는 것이 더 효율적이기 때문이다.
* _자원 공유의 측면에서 세가지 경우가 가능하다._
  * 부모 프로세스와 자식 프로세스가 모든 자원을 공유
  * 자식은 부모프로세스 자원의 일부분만을 공유하는경우 (메모리 또는 파일 따위)
  * 자식과 부모는 자원을 일절 공유하지 않고, 자식 프로세스가 OS로부터 직접 자원을 할당받는것
* _수행의 측면에서는 두가지 경우가 가능하다_
  * 부모와 자식이 병행(concurrently) 수행된다
  * 부모는 자식이 종료될때까지 기다린다
* _주소 공간 측면에서는 2가지 경우가 가능하다_
  * 자식은 부모의 복제이다 - 부모와 완전히 같은 일을 수행하는 경우
  * 자식은 따로 로드된 프로그램을 가지고있다 -부모와 다른 일을 수행하는 경우
* 예를 들어서, 백 만개의 수를 가진 리스트 내에서 가장 큰 수를 찾는 프로그램을 돌린다면?
  * 완전히 같은 종류의 5개의 프로세스를 리스트를 5조각으로 나눠 각각 할당시킨 후, 가장 큰수들을 뽑아낸다. (child processes)
  * 그 5개의 숫자들을 비교하여 가장 큰 수를 도출해낸다(parent process)
  * 이런 식으로 같은 종류의 자식 프로세스들이 필요하기 때문에 fork가 필요한 것.
  * devide & conquere(분할정복) 알고리즘 같은 경우에 사용된다.



* fork() & exec()
  * fork() 시스템 콜로 자식프로세스를 생성할 수 있다.
  * 새로운 프로세스는 원래 프로세스(부모)의 address space를 그대로 가져온다. 즉, 완전히 같은 일을 수행한다.
  * 부모와 자식 프로세스들은 fork이후에도 수행을 계속한다.
  * folk()의 반환코드는 경우에 따라 다르다.
    * 새로 생성된 자식 프로세스에게 반환 코드는 0이다.
    * 부모 프로세스에게는 자식프로세스의 식별자가 반환된다. (이 값은 0이 아니다.)
  * exec()은 메모리로 이진파일을 로드하고(이 때, exec() 시스템 콜을 포함하는 원 프로세스의 이미지를 파괴한다) 로드된 프로그램을 실행한다.

