OS 정리 8
========

Chapter 3 - Process
--------------

### InterProcess Communication

`Cooperating processes` 는 데이터와 정보를 교환할 수 있는 `Interprocess Communication(IPC)` 메커니즘을 필요로 한다. 

* 프로세스들이 `communicate` 하고 `synchronize`하기위한 기법이다.
* 기본적으로 두가지 모델이 있다.
  * `Shared memory` 공유 메모리 모델
  * `Message passing` 메시지 전달 모델
* 공유 메모리 모델 : 협력 프로세스들이 공유하는 메모리 영역이 만들어진다.
  * 공유 영역에 데이터를 `reading`하고 `writing`함으로써 통신(IPC)이 이루어진다.
* 메시지 전달 모델 : 협력 프로세스들 사이에 교환되는 메시지에서 통신이 일어난다.
  * 데이터를 `sending`하고 `receiving`함으로써 통신이 이루어진다.
* 많은 시스템이 둘 모두를 구현하고있다.



<center><img src="./img/Communications Models.png" style="width:60vw;"></img></center>

Message-passing

각 프로세스가 커널을 통하여 메시지를 주고 받는다.

Shared-memory

공유 memory region의 address를 두 프로세스 모두 알고 있어서, 해당 메모리에 데이터를 읽고 씀으로써 공유한다.

[shared-memory example](stackoverflow.com/questions/1268252/possible-to- share-in-memory-data-between-2-separate-processes)



* Message-passing 메시지전달 기법
  * 데이터 충돌이 없기 때문에, __적은 양의 데이터를 읽고 쓸__ 때 유용하다.
  * 공유메모리 기법보다 __구현하기 쉽다__.
* Shared-memory 공유메모리 기법
  * __최대 속도__ 와 __통신간의 편이성__ 을 제공한다.
  * 일상적인 메모리 접근이므로 메모리속도로 처리된다.
  * 메시지전달기법보다 __빠르다__
* _메시지전달 기법_ 은 일반적으로 시스템콜을 사용하므로 커널의 개입시간이 소모되어 더많은 시간이 필요하다.
* _공유메모리 기법_ 은 공유 메모리영역을 구축할 때에만 시스템콜이 필요하다(따라서 더 빠르다).



#### Shared-Memory System

* 공유메모리 생성
  * 공유 메모리 segment를 생성하는 프로세스의 주소공간에 위치한다.
  * 다른 프로세스들은 이 segment를 자신의 주소공간에 추가해야한다. 일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는것을 금지하기 때문이다.
* 공유메모리 제거
  * 제거하기 위해서는 모든 프로세스의 __동의__ 가 필요하다.
* 정보의 교환
  * 공유 공간 내의 데이터를 __읽거나 씀__ 으로써 이루어진다.
* 데이터의 형태와 위치는 OS가 아니라 이 프로세스들에 의해 결정된다. 한 프로세스가 데이터를 특정 위치에 남기면, 다른 프로세스는 그것을 읽고 사용한 뒤 지워야한다. 이것은 프로세스간의 작동이고, OS가 관리해주지 않는다.  따라서 Process는 synchoronized한 접근을 할 필요가 있다.



##### Producer-Consumer Problem 생산자-소비자 문제

* 협력 프로세스들의 일반적인 패러다임이다.
  * 생산자 프로세스는 정보를 생산하고, 소비자 프로세스는 이를 소비한다.
* 예시
  * 컴파일러는 어셈블리 코드를 생산하고, 어셈블러가 이것을 소비한다.
  * 이어서 어셈블러는 목적 모듈을 생산하고, 로더는 이것을 소비한다.
* 생산자 소비자 문제는 공유메모리로 해결될 수 있다.
  * 생산자와 소비자 프로세스들은 동시에 수행된다.
  * 그들은 공유메모리(내에 존재하는 버퍼)를 통해 상호작용한다.
  * 생산자는 항목을 생산하고 버퍼에 이것을 저장한다.
  * 소비자는 버퍼에서 항목을 소비한다.
  * 소비자가 사용가능한 항목만을 소비하기 위해서, 생산자와 소비자는 반드시 동기화되어있어야한다. 즉, 소비자는 만들어지지도 않은 항목을 소비할 수 없다.
* 두 타입의 버퍼가 존재한다.
  * `unbounded-buffer(무한버퍼)`는 버퍼 사이즈에 실질적 한계가 없다.
  * `bounded-buffer(유한버퍼)`는 버퍼의 크기가 고정되어있다고 가정한다.
  * 무한버퍼
    * 소비자는 새 항목이 생성되기를 기다려야 할 수도 있다.
    * 생산자는 새 항목을 _언제나_ 생성할 수 있다.
  * 유한버퍼
    * 소비자는 버퍼가 비어있으면 반드시 기다려야한다.
    * 생산자는 버퍼가 가득 차있으면 _반드시_ 기다려야한다.



<center><img src="./img/Bounded buffer.png" style="width:60vw;"></img></center>

* 유한버퍼 사용시
  * buffer.h 내에 producer.c / consumer.c 두 개의 프로그램이 속해있다고 가정하자.
  * shared buffer는 in / out 두개의 포인터를 가진 circular array처럼 작동한다.
  * producer와 consumer는 필요할 때 shared buffer에 접근하여 정보를 생산하거나 소비할 수 있다.
  * producer가 sleep하는동안 consumer가 읽어오고, p1은 나중에 그 space를 destory하여 비워놓는다(그렇지 않으면 쓰레기값이 남게된다).
  * 만약 producer와 consumer가 동시에 버퍼에 접근한다면 어떻게 하는가? 이것은 다음챕터에서 논의한다



Shared memory의 사용사례는 무엇이 있을까?

예를들어 naver에서 파일을 받으면서 동시에 파일을 읽고싶다면, in 프로그램과 out 프로그램을 동시에 사용하고 있을것이다. 따라서 shared memory를 사용하고 있을것이라고 추측할 수 있다.



#### Message-Passing System

* OS는 메시지 전달 설비를 통하여 다음과 같은 협력 프로세스간의 통신수단을 제공해준다.

  * _네트워크로 연결된 별개의 컴퓨터에 존재하는 프로세스들_
  * _공유 변수를 사용하지 않고 서로 상호작용하려는 프로세스들_

* 최소 두가지 연산을 제공한다.

  * `send` : 고정길이 또는 가변길이의 메시지를 보낸다.
  * `receive` 
  * 서로 상호작용할 때에 __system call__ 을 사용한다.

* 만약 프로세스 P와 Q가 상호작용한다면, 다음이 필요하다.

  * 둘 사이의 `communication link`를 구축하는것
  * `send`/`receive` 연산을 통해 메시지를 교환하는것

* 통신 연결(communication link)의 구현

  * 다양한 방식으로 구현될 수 있다 - 시그널, 파이프, 소켓, rpc 등..
  * computer 1과 computer 2에 각각 존재하는 p1과 p2는 물리적으로 분리되어 있어 pid만으로 각 프로세스를 특정하기 어렵다. 따라서 ip 주소와 pid를 같이 전송하는 방식들을 이용한다. 이러한 방식 중 하나가 소켓.

* 논리적으로 구현하는 __세가지__ 방법들이 있다.

  * 직접 또는 간접 통신
  * 동기식 또는 비동기식 통신
  * 자동 또는 명시적 버퍼링

* 직접통신

  * 두개의 주소지정 방식이 있다.
    * __Symmetry__ 대칭
      * 송수신자가 각각의 이름을 모두 알고있음
    * __Asymmetry__ 비대칭
      * 송신자만 수신자의 이름을 알고, 수신자는 송신자의 이름을 모른다
  * send(P, message) : 프로세스 p에게 message를 보낸다
  * receive(id, message) : 임의의 프로세스로부터 메시지를 수신한 뒤, 변수 id를 송신자의 프로세스 이름으로 설정한다.

  * 직접 통신의 __단점__(symmetry & assymetry)
    * 프로세스를 정확히 지정하므로 모듈화가 제한된다.
    * 프로세스의 id를 바꾸려면 모든 다른 프로세스 정의들을 검사해야할 수도 있다.

* 간접 통신

  * 메시지들이 메일박스 또는 포트로 송신되고, 그것으로부터 수신된다.
    * 메일박스는 프로세스들에 의해 메시지들이 넣어지고, 메시지들이 제거될 수 있는 객체이다.
    * 각 메일박스는 unique id를 가지고 있다.
    * 프로세스들은 메일박스를 공유하고 있을 때에만 통신할 수 있다.
  * 간접 통신 링크의 속성
    * 한 쌍의 프로세스 사이의 연결은 프로세스들이 공유 메일박스를 가질때에만 구축된다.
    * 연결은 두개 이상의 프로세스들과 연관될 수 있다.
    * 프로세스 쌍마다 여러개의 통신링크를 공유할 수 있다.
    * 링크는 전방향 또는 단방향일 수 있다.

* 동기화

  * 메시지 전달은 __blocking__ 봉쇄형 또는 __non-blocking__ 비봉쇄형으로 나뉜다.
  * 봉쇄형은 동기식이다.
    * 송신자가 보낸 메시지를 수신자가 받기 전까지는 또 다른 메시지를 보낼 수 없다.
    * 수신자는 메시지를 받기 전까지는 접근할 수 없다.
  * 비봉쇄형은 비동기식이다.
    * 송신자가 보낸 메시지를 수신자가 받기 전에도 메시지를 계속 보낼 수 있다.
    * 수신자는 메시지가 유효(valid)하든 없(null)든 메시지를 수신받을 수 있다.
  * send()와 receive()가 모두 봉쇄형이라면, 송수신자 사이의 랑데부(rendezavous)를 이루게 된다.
    * 송수신 요청이 모두 들어오면, buffer(mailbox)에 따로 메시지를 저장해 둘 필요 없이 송신자의 메시지를 그대로 수신자 영역에 복사한다. 즉, 직접 송수신자가 만나게 되는 것(랑데부)이다.

* Buffering

  * 통신링크에 연결된 __메시지들의 큐__ 이다.
    * 메시지들은 통신간에 임시 큐에 존재한다.
  * 이러한 큐를 구현하는 데에는 __세가지 방법__ 이 있다.
    * 무용량 : 큐에 0개의 메시지가 존재
      * 큐의 최대 길이가 0
      * 송신자는 수신자가 메시지를 받을 때까지 기다려야한다(랑데부)
    * 유한용량 : 유한한 길이, 즉 최대 n개의 메시지를 가진다.
      * 송신자는 link가 꽉 차면 가용한 공간이 생길때까지 봉쇄되어야한다.
    * 무한용량 : 잠재적으로 무한한 길이를 가진다.
      * 송신자는 결코 봉쇄되지 않는다(기다릴 필요가 없다).







