OS 정리 9
========

Chapter 4 - Multithreaded Programming
--------------

### Thread?

* __프로세스 내의 control의 흐름이다.__

* 싱글스레드 프로세스, 멀티스레드 프로세스

* _CPU 이용의 기본 단위이다._ 다음으로 이루어져있다.
  * __스레드 ID, Program counter(PC), 레지스터 집합, 스택__
* 같은 프로세스 내에 속한 _다른 스레드_ 와 __code section, data section, 그 밖의 OS자원(open files and signal)__ 을 공유한다.
* 프로세스가 다수의 제어 스레드를 가진다면, _동시에 하나 이상의 작업을 수행할 수 있다._

* 교수님 설명
  * 스레드란 프로세스의 특정 위치를 가리키는 포인터와 같다. 여러 개의 스레드가 있다는 것은 한번에 여러개의 포인터를 가지고 있어 CPU가 명령하여 한번에 여러 변수에 접근하고, 여러 일을 처리할 수 있다는 의미이다.

<center><img src="./img/Single and Multithreaded Processes.png" style="width: 60vw;"></img></center>



#### Multi-threaded programs

* 현대 OS 소프트웨어 패키지 대부분은 _멀티 스레드_ 를 이용한다.
* 웹브라우저는 아래와 같이 작동한다.
  * 한 스레드는 이미지나 텍스트를 표시한다
  * 다른 스레드는 네트워크로부터 데이터를 불러온다
* 워드프로세서는 이런식으로 작동한다
  * 한  스레드는 화면을 표시한다.
  * 다른 스레드는 사용자의 키 입력에 반응한다.
  * 세 번째 스레드는 스펠링와 문법을 체크한다.
* 예시 - 웹 서버
  * _싱글 스레드 웹서버_ : 클라이언트는 요청이 응답되기 전까지 기다려야한다. (한번에 하나의 클라이언트 요청만을 처리한다)
  * _멀티 프로세스 웹서버_ : 스레드가 대중화되기 전에 사용되었던 방식이며, 새로운 프로세스를 생성하는 데에 __훨씬 더 많은 overhead__ 를 발생시킨다. 
  * _멀티 스레드 웹서버_ : 다수의 클라이언트에게 동시 서비스를 제공하며, 스레드 생성에 __훨씬 더 적은 overhead__ 가  발생된다.
* 다수의 OS 커널은 multi-threaded이다.
  * 커널 안에서 다수의 스레드가 동작한다.
  * 각 스레드는 장치 또는 interrupt 처리 등의 특정 작업을 수행한다.



#### Benefits of multi-threaded programming

* _Responsiveness_ 응답성
  * _Interactie application_ 의 멀티스레딩은 프로그램의 일부분이 block되거나 긴 연산작업을 수행하더라도 계속해서 프로그램이 수행되도록 한다.
* _Resource Sharing_ 자원 공유
  * 스레드는 자신이 속한 프로세스의 resource와 memory를 공유한다.
* _Economy_ 경제성
  * 프로세스 내의 스레드는 자원을 공유하므로, _스레드를 생성하고 context-switch하는것이 보다 더 경제적_ 이다.
  * Solaris에서 프로세스를 생성하는 시간은 스레드를 생성하는 시간의 30배이다.
* _Untilization of Multi-Processor Architectures_ 멀티프로세서 구조의 사용
  * 각기 다른 프로세서에서 스레드들이 _병렬 처리(running in parellel)_ 될 수 있다.

\- [Using Thread example](stackoverflow.com/questions/2846653/how-can-i-use-threading-in-python)



### Two types of threads

* `User Thread` 사용자 스레드
  * _프로그래머 차원에서 관리되고(visible), 커널은 지원하지않는(unknown) 스레드_
  * 일반적으로, 사용자 스레드는 _커널의 개입이 필요하지 않기때문에_ 커널 스레드보다 _빠르다_.
* `Kernel Thread` 커널 스레드
  * OS 커널은 커널 레벨 스레드를 지원하고 관리한다.



#### User Threads

* _사용자 수준의 스레드 라이브러리_ 에 의해 관리된다.
  * 유저 스레드는 커널을 커널 위에서 지원되며, 커널의 지원 없이 관리된다.
* 주요 스레드 라이브러리
  * POSIX Pthreads
  * Win32 threads
  * Java threads



#### Kernel Threads

* 커널에 의해 지원된다.
  * OS에 의해 __직접적으로_directly___  지원되고 관리된다. 따라서 사용자는 커널 스레드를 생성할 수 없다.
* 예시
  * Window XP/2000
  * Solaris
  * Linux
  * Tru64 UNIX
  * MAC OS X



---

### Multithreading Models

* `user threads` 와 `kernel threads` 사이의 관계
* _Many-to-One_ 다대일
* _One-to-One_ 일대일
* _Many-to-Many_ 다대다



#### Many-to-One 다대일 모델

* _여러 사용자 스레드가 하나의 커널 스레드로 연결_
  * 스레드 관리는 사용자 영역의 스레드 라이브러리에 의해 행해진다.
  * 원하는 만큼의 사용자 스레드를 생성할 수 있으므로 효율적이다.
  * 한 스레드가 봉쇄형_blocking_ 시스템 콜을 할 경우 __전체 프로세스가 block__ 된다.
  * 한번에 하나의 스레드만이 커널에 접근할 수 있으므로, 멀티 프로세서에서 돌아도 스레드가 병렬로 작동할 수 없다.
* 예시
  * Solaris Green Threads
  * GNU Portable Threads



#### One-to-One 일대일 모델

* _한 사용자 스레드가 하나의 커널 스레드에 각기 매칭_
  * 다대일 모델보다 더 많은 concurrency(병렬성)을 제공한다.
  * 한 스레드가 봉쇄형 시스템 콜을 하더라도 다른 스레드가 동작할 수 있다.
  * 사용자 스레드를 생성하려면 대응하는 커널 스레드를 생성해야한다. - __ovehead를 유발__
  * 일반적으로 한 프로세스에 지원가능한 스레드 수가 다대일 모델보다 제한되어있다. - __너무 많은 스레드를 생성하지 않도록 주의__
* 예시
  * __Window NT/XP/2000__
  * __Linux__
  * __Solaris 9와 그 이후 버전__



