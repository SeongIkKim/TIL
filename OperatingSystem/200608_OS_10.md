OS 정리 9
========

Chapter 4 - Multithreaded Programming
--------------

### Threading Issues

#### Thread Pools

* 스레드가 작업을 하기 전까지 기다리는 _스레드의 대기장소(풀)_
  * 프로세스는 시작할 때 여러 스레드를 만들어 놓고 풀에 넣어둔다.
  * 요청이 들어오면, 서버는 풀에 있는 스레드 중 하나에게 서비스 요청을 할당한다.
  * 서비스를 끝낸 스레드는 풀로 돌아와서 다른 일이 들어올 때까지 다시 기다린다.
  * 풀에 가용한 스레드가 없다면, 서버는 풀 내에 가용스레드가 하나 생길때까지 기다려야한다.
* 장점
  * 새로운 스레드를 만드는것보다 기존 스레드로 서비스 해주는것이 경미하게 더 빠르다.
  * 풀의 사이즈에 맞게 응용프로그램 내의 스레드 개수를 제한할 수 있다. 많은 스레드를 병렬처리 할 수 없는 시스템에 도움이 된다.



## Chapter 5 - Process Scheduling

### Basic Concepts

* `Process Scheduling` 이란
  * 다중 프로그램 OS의 기본이다.
* 용어 정리
  * CPU 스케줄링, 프로세스 스케줄링, 커널 스레드 스케줄링
  * 이 책에서는 프로세스 스케줄링과 스레드 스케줄링을 상호 교환적으로 사용한다. 일반적인 스케줄링 개념은 프로세스 스케줄링이라고 하고, 스레드에 국한된 경우에만 스레드 스케줄링이라는 용어를 사용할 것이다.
* `single-processor system` 에서
  * 한 순간에는 오직 하나의 프로세스만이 실행될 수 있다.
  * 나머지 프로세스는 CPU가 자유 상태가 되어 다시 스케줄될 수 있을 때까지 기다려야한다.
  * 실행중인 프로세스가 대기 상태로 진입하면
    * OS는 CPU 이용률을 최대화하기 위해 다른 프로세스에 CPU를 할당할 것이다.
    * 즉, 실행 중인 프로세스를 항상 가지도록 하는것이 다중 프로그래밍의 목적이다.
    * 한 프로세스가 대기해야 할 때마다, 다른 프로세스가 CPU 사용을 양도받을 수 있다.
* 프로세스 스케줄링은
  * OS의 기본적인  기능이다.
  * __준비 큐로부터 프로세스를 골라서 CPU에 할당하는 것__ 이다.
* `Maximum CPU untilization` 은 멀티프로그래밍에 의해 얻어진다.
  * 정확히는 프로세스 스케줄링에 의해 얻어진다.



### CPU - I/O burst cycle

* _프로세스 실행_ 은 CPU 실행(CPU burst)와 입출력 대기(I/O burst)로 이루어져 있다.
* 프로세스는 두 상태간을 왔다갔다 한다.
  * 프로세스 실행은 CPU burst로 시작해서, I/O burst가 발생하고, 다시 또 다른 CPU burst가 발생하고.. 이의 반복이다.
  * 결국, 마지막 CPU burst는 실행을 종료하기 위한 시스템콜과 함께 끝난다.
* 프로세스의 `CPU burst distribution` 지속시간은 컴퓨터와 프로세스에 따라 아주 다르다.



<center><img src="./img/Alternating Sequence of CPU & I/O Bursts.png" style="width:60vw"></img></center>



