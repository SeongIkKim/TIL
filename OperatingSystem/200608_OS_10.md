OS 정리 9
========

Chapter 4 - Multithreaded Programming
--------------

### Threading Issues

#### Thread Pools

* 스레드가 작업을 하기 전까지 기다리는 _스레드의 대기장소(풀)_
  * 프로세스는 시작할 때 여러 스레드를 만들어 놓고 풀에 넣어둔다.
  * 요청이 들어오면, 서버는 풀에 있는 스레드 중 하나에게 서비스 요청을 할당한다.
  * 서비스를 끝낸 스레드는 풀로 돌아와서 다른 일이 들어올 때까지 다시 기다린다.
  * 풀에 가용한 스레드가 없다면, 서버는 풀 내에 가용스레드가 하나 생길때까지 기다려야한다.
* 장점
  * 새로운 스레드를 만드는것보다 기존 스레드로 서비스 해주는것이 경미하게 더 빠르다.
  * 풀의 사이즈에 맞게 응용프로그램 내의 스레드 개수를 제한할 수 있다. 많은 스레드를 병렬처리 할 수 없는 시스템에 도움이 된다.



## Chapter 5 - Process Scheduling

### Basic Concepts

* `Process Scheduling` 이란
  * 다중 프로그램 OS의 기본이다.
* 용어 정리
  * CPU 스케줄링, 프로세스 스케줄링, 커널 스레드 스케줄링
  * 이 책에서는 프로세스 스케줄링과 스레드 스케줄링을 상호 교환적으로 사용한다. 일반적인 스케줄링 개념은 프로세스 스케줄링이라고 하고, 스레드에 국한된 경우에만 스레드 스케줄링이라는 용어를 사용할 것이다.
* `single-processor system` 에서
  * 한 순간에는 오직 하나의 프로세스만이 실행될 수 있다.
  * 나머지 프로세스는 CPU가 자유 상태가 되어 다시 스케줄될 수 있을 때까지 기다려야한다.
  * 실행중인 프로세스가 대기 상태로 진입하면
    * OS는 CPU 이용률을 최대화하기 위해 다른 프로세스에 CPU를 할당할 것이다.
    * 즉, 실행 중인 프로세스를 항상 가지도록 하는것이 다중 프로그래밍의 목적이다.
    * 한 프로세스가 대기해야 할 때마다, 다른 프로세스가 CPU 사용을 양도받을 수 있다.
* 프로세스 스케줄링은
  * OS의 기본적인  기능이다.
  * __준비 큐로부터 프로세스를 골라서 CPU에 할당하는 것__ 이다.
* `Maximum CPU untilization` 은 멀티프로그래밍에 의해 얻어진다.
  * 정확히는 프로세스 스케줄링에 의해 얻어진다.



### CPU - I/O burst cycle

* _프로세스 실행_ 은 CPU 실행(CPU burst)와 입출력 대기(I/O burst)로 이루어져 있다.
* 프로세스는 두 상태간을 왔다갔다 한다.
  * 프로세스 실행은 CPU burst로 시작해서, I/O burst가 발생하고, 다시 또 다른 CPU burst가 발생하고.. 이의 반복이다.
  * 결국, 마지막 CPU burst는 실행을 종료하기 위한 시스템콜과 함께 끝난다.
* 프로세스의 `CPU burst distribution` 지속시간은 컴퓨터와 프로세스에 따라 아주 다르다.



<center><img src="./img/Alternating Sequence of CPU&IO Bursts.png" style="width:60vw;"></img></center>



#### Histogram of CPU-burst Times

<center><img src="./img/Historgram of CPU-burst Times.png" style="width:60vw;"></img></center>

* CPU 버스트 분포는 일반적으로 다음과 같은 특징을 가진다.
  * 지수형_exponential_ 또는 초지수형_hyper-exponential_ 이다.
  * __짧은 CPU 버스트가 많이 있으며, 긴 CPU 버스트가 적게 있다.__
  * 이 두가지 종류의 버스트가 랜덤하게 반복된다. 이 분포를 고려하여 CPU 스케줄링 알고리즘을 선택한다.
* 입출력 중심 프로세스는 다수의 짧은 CPU 버스트를 가질 수 있다.
* CPU 중심 프로세스는 적은 수의 긴 CPU 버스트를 가질 수 있다.



#### Process Scheduler

* OS 모듈의 한 종류이다.
* 메모리에서 실행 준비가 된 프로세스들 중 하나를 __골라__ CPU를 __할당__ 한다.
* `CPU scheduling decisions` 은 프로세스가 다음 상황일 때 일어난다.
  1. running -> waiting : 입출력 요청, 또는 자식 프로세스들 중의 하나가 종료되기를 기다리기 위해 wait()를 호출할 시
  2. running -> ready : 인터럽트 발생 시
  3. waiting -> ready : 입출력 종료(완료) 시
  4. running -> terminates : 프로세스 종료시
  5. new state -> ready  : 프로세스 시작 시
* 상황 1, 4에서만 스케줄링이 발생할 경우, `non-preemptive(비선점적)` 이라고한다.
* 상황 2, 3, 5에서는 `preemptive(선점적)`이라고 한다.



#### Non-preemptive vs Preemptive

* `Non-preemptive Scheduling`
  * 한 프로세스에 CPU가 할당되면, 해당 프로세스는 CPU를 release할 때까지 계속 점유한다.
  * 종료나 waiting 상태로 전환함으로써 CPU를 release한다.
  * Window 3.x 버전에서 사용되었다.
  * '내가 수행할거니 네가 잠시 멈춰라'
* `Preemptive Scheduling`
  * 현재 실행중인(running) 프로세스는 언제든 다른 프로세스와 교체될 수 있다.
    * 인터럽트가 언제든 일어날 수 있기 때문이다.
  * 대부분의 현대 OS는 이 방식을 사용한다. (Windows, Mac OS X, UNIX)
  * 프로세스간 공유 데이터에 접근하는 경우 비용이 발생한다.
  * OS 커널 설계에 영향을 준다.
    * 특정 OS(UNIX)는 context switch 전에 종료 시스템콜을 기다리거나, I/O block이 일어날 때까지 기다린다.
    * 인터럽트는 어느 시점에서건 일어날 수 있으므로, 인터럽트에 의해 영향을 받는 중요 코드 부분은 보호되어야한다. 이 때, 코드 진입구간에서 인터럽트를 disabling하고 코드 출구구간에서 인터럽트를 enabling한다.
  * '네가 수행 다하면 내가 수행할게'