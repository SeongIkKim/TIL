OS 정리 11
========

Chapter 6 - Process Synchronization
--------------

### Background

* _공유 데이터_ 에 동시접속하는것은 데이터 `inconsistency` 를 초래할 수 있다.
* `data consistency` 를 유지하는 것은 협력프로세스들이 순서대로 수행되도록 보장해주는 메커니즘이 필요하다.
* 모든 버퍼가 꽉 차는 생산자-소비자 문제를 해결하려 한다고 생각해보자.
  * 버퍼의 아이템 수 track을 int 카운터로 유지해서 해결할 수 있다.
  * 처음에 카운터를 0으로 둔다.
  * _생산자_ 가 새 아이템을 만들면 카운트를 증가시킨다.
    * 카운터 == buffer_size일 때 생산자는 생산할 여분의 공간이 없으므로 무한루프를 돈다.
  * _소비자_ 가 아이템을 사용하면 카운트를 감소시킨다.
    * 카운터 == 0일 때 소비자는 소비할 아이템이 없으므로 무한 루프를 돈다
* `Race condition`
  * 생산자와 소비자 루틴 각각은 올바를지라도, __동시에 수행한다면 잘못 수행 될 수 있다__.
  * 다음을 가정해보자.
    * __카운터__ 변수 값이 현재 5이고, 생산자와 소비자가 동시에 각각 증가와 감소를 시도했을때
    * 두 명령문의 수행 이후 카운터는 __4, 5, 6 중 어느것이 될 지 모른다.__
  * 왜 그러한가?
    * counter++와 counter-- 연산은 `atomic` 하지 않기 때문이다.
    * assembly로 바꿀 경우 여러가지 atomic한 연산을 거친다.

<center><img src="./img/Race Condition.png" style="width:60vw;"></img></center>

* ++ 연산에서, 카운터를 레지스터1로 가져와서, 레지스터 내의 값을 1 올리고 다시 카운터에 저장한다. -- 연산은 반대로 동작한다.
* 그런데 만약 이 연산들이 동시에 수행되어 뒤섞인다면?
  * 레지스터 1로 카운터를 가져와서 1 올린다.
  * 레지스터 1을 저장하기 전에, 레지스터 2에서 카운터 2를 가져와서 1을 뺀다.
  * 카운터에 레지스터 1을 저장한뒤, 곧바로 이어서 카운터에 레지스터 2를 저장한다(덧씌운다).
  * 이 경우 카운터에는 레지스터 2의 값만 남게된다. 따라서 5가 아니라 4가 된다. ++연산은 저장되지 않는 것이다.

<center><img src="./img/not atomic.png" style="width:60vw;"></img></center>

* 두 프로세스가 동시에 카운터 변수에 접근하도록 만들기 때문에 _부정확한 상태_ 에 도달할 수 있다.
* 즉 `Race Condition` 이란
  * 동시에 여러개의 프로세스가 동일한 자료를 접근하여 조작하고, __그 실행결과가 접근이 발생한 특정 순서에 의존하는 상황__이다.
* 경쟁 상황를 예방하기 위해서는
  * 한번에 한 프로세스만 카운터 변수(공유 데이터)에 접근하도록 해야한다.
  * 어떤 형태로든 프로세스들을 _동기화_ 할 필요가 있다.



---

### Critical-Section(CS) Problem 임계영역 문제

* 시스템이 n개의 프로세스로 이루어져 있다면 각 프로세스는 `critical section` 으로 불리는 _코드 조각_ 을 가지고 있다.
  * 이 코드 조각 안에서 프로세스는 __변수 값을 바꾸고, 테이블을 갱신하고, 파일을 쓰는 등의 작업을 수행__ 한다.
  * 시스템은 임계 영역 내에서 __동시에 두개의 프로세스가 실행되지 않도록__ 해야한다.
* __임계 영역 문제__ 해결법
  * 프로세스가 협력할 때 사용할 수 있는 _protocol을 디자인_ 한다.
  * 각 프로세스는 임계 영역에 들어가기 위해 허가를 받아야한다.
  * 이 요청을 수행하는 코드 섹션을 `entry section` 이라고 한다.
  * 임계 영역의 뒤에는 `exit section` 이 따라 붙는다.
  * 코드의 나머지부분들은 총칭하여 `remainder section` 이라고 한다.

<center><img src="./img/Critical-Section Problem.png" style="width:60vw;"></img></center>

* 임계 영역 내에서는 다른 프로세스가 방해할 수 없다(인터럽트 할 수 없다)

* CS의 example은 강의 슬라이드를 참조할것.



* __임계영역 문제의 해결법__ 은 다음 세가지 요구조건을 만족해야한다.
  * `Mutual Exclusion` 상호배제 : 한 프로세스가 자신의 임계영역에서 수행된다면, 다른 프로세스들은 그들 자신의 임계영역에서 실행될 수 없다.
  * `Progress` 진행 : 자기의 임계영역에서 실행 중인 프로세스가 없고, 자신의 임계영역으로 진입하려고 하는 프로세스들이 있다면, _나머지 영역에서 실행중이지 않은 프로세스들만 임계 영역으로 진입할 프로세스를 결정하는 데에 참여할 수 있으며_, 이 선택은 무기한 연기될 수 없다 - _deadlock-free condition_ 
  * `Bounded Waiting` 한정된 대기 : 프로세스가 자기의 임계 영역에 진입하려는 요청을 한 후부터 그 요청이 허용될 때 까지 다른 프로세스들이 자신의 임계영역에 진입하도록 허용되는 횟수는 한계 또한 제한이 있어야 한다. - _starvation-free condition_



#### Perterson's Solution - 두 프로세스간의 해결책

* 제한사항 : 두 프로세스간에만 사용할 수 있는 해결책이다(n개의 프로세스에서는 사용 불가하다)
  * __소프트웨어 기반 해결책__ 이다
  * LOAD와 STORE 연산이 __atomic__ 하다고 가정한다. 즉, 두 연산은 도중에 인터럽트 될 수 없다.
* 두 프로세스는 두개의 변수를 공유한다.
  * int turn
    * turn 변수는 어떤 프로세스가 임계 영역에 들어갈 차례인가를 보여준다.
  * boolean flag[2]
    * flag array는 프로세스가 임계영역에 들어갈 준비가 되었는지를 나타낸다.
    * flag[i] = true이면 프로세스 i가 임계영역에 들어갈 준비가 되었다는 뜻.

<center><img src="./img/Algorithm for Process i.png" style="width:60vw;"></img></center>

* flag[i]는 준비완료 상태이고, 지금부터 프로세스 i(이하 Pi)는 먼저 프로세스 j(이하 Pj)에게 순서를 양보한다(turn = j;). 즉, Pj가 임계 영역으로 진입하기를 원한다면 진입가능하다는 것을 보장한다.
* Pj의 차례이고, j가 준비완료 상태인 동안 Pi는 while문을 돌며 기다리고 있다(busy waiting).
* 만약 turn == i, 즉 Pi의 차례이거나 && flag[j] == false, 즉 Pj가 자원을 쓸 준비가 되어있지 않다면 Pi는 while문을 빠져나와 임계영역에 진입한다.
* 임계영역 부분에서 Pi는 공유 메모리를 조작하는 자신의 연산을 수행한다.
* 임계영역이 끝나고 나면 flag[i]는 false가 되어 교착 상태를 예방한다.

<center><img src="./img/Algorithm for Process i and Process j.png" style="width:60vw;"></img></center>

* 피터슨 해결책은 임계영역 해결책의 세 가지 조건을 모두 만족한다.
  * `Mutual Exclusion`
    * Pi는 __flag[j] == false__이거나 __turn == i__ 일때만 임계영역에 진입한다.
    * Pi는 __flag[i] == true__ 여야만 진입한다.
    * turn의 변수값은 0 또는 1 둘 중 하나이지 동시에 두 값을 가질 수 없으므로, Pi와 Pj는 동시에 임계영역으로 진입할 수 없다.
  * `Progress`
    * Pi는 flag[j] == true 면서 turn == j 일때만 멈추어 있다.
  * `Bound Waiting`
    * Pi는 Pj가 최소 한번 진입한 후에 임계영역에 진입할 것이다.
    * Pi는 busy waiting(while문)동안 turn 값(j)을 바꾸지 않는다. 즉, 자기가 스스로 turn을 잡아 챌 수 없다. 반드시 Pj에 의해서만 turn이 i로 넘어온다. 양보를 전제로 하므로, 스스로 계속해서 critical section을 사용할 수 없도록 제한을 걸어둔 셈이다. 따라서 Pi가 수행되면 뒤이어 Pj가 수행될 것이고, Pj가 수행되면 뒤이어 Pi가 수행되므로 공평하게 임계영역에 진입하게 된다.
  * __Synchronize의 개념을 보여주는 중요한 코드__ 이므로 반드시 외우도록 하자.

<center><img src="./img/What is the Problem in Pi.png" style="width:60vw;"></img></center>

* 만약에 코드가 위와 같았다면, 어떤 문제가 생겼을까?
  * 첫번째 코드 - turn 변수만을 사용했을 경우
    * turn이 자기 차례일 때만 진입할 수 있고, 임계영역이 끝나고 나면 turn을 넘긴다. 따라서 Mutual Exclusion을 만족한다.
    * Pj가 수행 후 remainder section에 들어갔고, Pi가 turn을 넘겨받아 임계영역을 수행한 뒤 remainder section도 수행하고 다시 돌아왔다고 치자.
    * 이 때, 만약 Pj가 계속해서 Remainder Section을 진행하고있다면, 임계영역에 진입한 프로세스가 없음에도 불구하고 turn을 Pi에게 넘겨주지 않았으므로 Pi는 계속 기다리기만 해야한다.  따라서 Progress를 충족하지 못한다
  * 두번째 코드 - flag 변수만을 사용했을 경우
    * 코드 진입시 자신의 flag를 true로 바꾸어 임계영역 진입을 준비한다.
    * 상대의 flag == true일때 임계영역에 진입할 수 없으므로 Mutual Exclusion을 만족한다.
    * 임계영역을 모두 수행하고 나면 flag를 false로 바꾼다.
    * 그렇지만, 만약 flag[i] = true와 flag[j] = true가 잇달아 수행되어 두 프로세스 모두 무한 while루프를 돌게된다면, 임계영역에 진입한 프로세스가 없음에도 불구하고 두 프로세스는 계속 busy waiting만 하게된다. 따라서 Progress를 충족하지 못한다.



#### Bakery Solution - 다중프로세스간의 해결책

* 추후에 정리



#### Decker's Algorithm - 두 프로세스간의 해결책

* 추후에 정리

