OS 정리 13
========

Chapter 7 - Deadlocks
--------------

### Deadlock Problem

* 대기중인 모든 프로세스들이 _자원을 holding한 상태_ 이며 다른 프로세스가 holding하고 있는 _자원을 얻기를 기다리고있는_ 상태
* 예시 1
  * 시스템은 두개의 테이프 드라이브를 가지고 있다.
  * P1과 P2는 각각 하나의 테이프 드라이브를 가지고 있으며 나머지 한개를 필요로 한다.
* 예시 2
  * 1로 초기화된 세마포어 A와 B가 있다
    * P0은 P1을, P1은 P0을 wait한다
* 예시 : 다리건너기
  * 교통은 _한 방향_ 으로만 이루어진다.
  * 다리의 각 섹션을 _resource_ 로 볼 수 있다.
  * 교착상태가 일어나면, 한 차가 뒤로 물러서면 해결할 수 있다. (리소스를 선점하고 롤백하는것)
  * 각 차들은 교착상태가 일어나면 물러서야 할 수도 있다.
  * __기아__ 가 일어날 수도 있다.

---

### System Model

* m개의 자원(자원 타입 : CPU 사이클, 메모리 공간, 입출력 장치 등)이 있을 때
* 각 자원 R은 __여러개의 인스턴스 W__ 를 가지고 있다.
* 각 프로세스는 다음에 따라 자원을 사용할 수 있다.
  * 요청 : 요청이 즉시 허용되지 않으면 요청 프로세스는 자원을 얻을 때까지 대기해야한다.
  * 사용 : 프로세스는 자원에 대해 작업을 실행할 수 있다.
  * 방출 : 프로세스는 자원을 방출한다.



---

### Deadlock Characterization

* 아래는 데드락의 특징이지, 조건이 아니다.
* 데드락은 네 개의 조건을 동시에 성립할 때 발생할 수 있다.
  * `Mutual exclusion`  상호배제 : 한번에 한개의 프로세스만 자원을 사용할 수 있다.
  * `Hold and wait` 점유하며 대기: 프로세스는 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유한 자원을 추가로 얻기 위해 반드시 대기해야한다.
  * `No preemption` 선점 불가 : 자원은 강제적으로 방출될 수 없고, 점유하고 있는 프로세스가 태스크를 종료한 후 _그 프로세스에 의해 자발적으로만_ 방출될 수 있다.
  * `Circular wait` 순환 대기 : 대기하고 있는 프로세스집합에서 각 프로세스는 순환적으로 다른 프로세스의 자원을 기다리고있다.



#### Resource-Allocation Graph

* 데드락은 `system resource-allocation graph` 라고하는 _directed graph_로 보다 정확하게 기술할 수 있다.
* 정점 집합 V(Vertex)는 두가지 타입으로 나뉜다.
  * P  : 시스템 내 모든 활성 _프로세스_ 의 집합
  * R : 시스템 내 모든 _자원 타입_ 의 집합
* 간선 집합 E(Edge)는 두 가지 타입으로 나뉜다.
  * 요청(request) 간선 : P->R 간선
  * 할당(assignment) 간선 : R->P 간선
* *자원 내 인스턴스는 자원에 있는 점으로 표현된다.

<center><img src="./img/Example of a Resource Allocation Graph.png" style="width:60vw;"></img></center>

* 위와 같은 그래프가 있다고 할때, 데드락이 일어나는가? (선점불가라고 가정한다)
* cycle을 포함하지 않으므로 교착상태가 존재할 수 없다.

<center><img src="./img/Resource Allocation Graph with a Deadlock.png" style="width:60vw;"></img></center>

* _R1은 하나의 인스턴스만을 가지고 있다._
* 위의 그래프에서는 cycle이 완성되었으므로, 데드락이 발생한다.

<center><img src="./img/Resource Allocation Graph With A Cycle But No Deadlock.png" style="width:60vw;"></img></center>

* _R1은 두개의 인스턴스를 가지고 있다._
* 그러나 cycle이 있다고 해서 __반드시 데드락이 생기는 것은 아니다.__



* 따라서,
  *  그래프에 __cycle이 없으면__ , __데드락이 발생하지 않는다__ 
  * 만약 그래프에 __cycle이 있다면__ ,
    * 자원 타입에 인스턴스가 _하나밖에_ 없다면, __데드락이 일어난다__
    * 자원 타입에 인스턴스가 _여러 개_ 있다면, __데드락이 일어날 가능성이 있다__



---

### Methods for Handling Deadlocks

1. _시스템이 데드락에 빠지지 않도록_ 보장한다.
   * _데드락을 피하거나 예방하기 위한 프로토콜_ 을 사용한다.
   * __데드락 예방, 데드락 회피__
2. 시스템이 데드락에 돌입하는 것을 허용한 뒤 회복시킨다
   * __데드락 탐지, 데드락 회복__
3. 문제를 무시하고, 데드락이 시스템에서 결코 발생하지 않는 척 한다.
   * UNIX와 Windows를 포함한 대부분의 OS에서 사용된다.
   * 이 경우 데드락을 해결하는 것은 프로그램을 짜는 개발자에게 달려있다.



---

### Deadlock Prevention

* 앞의 네가지 필요조건 중 최소 하나가 성립되지 않도록 보장하여 데드락을 예방한다.
* 요구조건이 성립될 수 있는 방법을 제한한다.
  * `Mutual Exclusion` - _공유 가능한 자원_ 들에는 성립될 필요가 없지만, _공유 불가능한 자원_ 들에 관해서는 반드시 성립해야한다.
  * `Hold and Wait` - _프로세스가 자원을 요청할 때, 다른 자원을 점유하고 있지 않아야 한다._ 
    * 프로세스가 수행 전에 자신의 모든 자원을 요청하여 할당받도록 한다.
    * 프로세스가 자원을 전혀 갖고 있지 않을때만 자원을 요청할 수 있도록 허용한다.
    * 많은 자원들이 할당된 후 오랫동안 사용되지 않기 때문에, 자원 이용률이 낮다 ; 여러 개의 인기자원을 필요로 하는 프로세스는 최소한 하나의 자원의 계속 다른 프로세스에 할당되어있어 기아문제가 발생할 수 있다.
  * `No Preemption`  - 이미 할당된 자원이 선점되지 않아야한다.
    * 만약 어떤 자원을 점유하고 있는 프로세스가 즉시 할당받을 수 없는 다른 자원을 요청하면, 현재 점유하고 있는 모든 자원들은 방출된다.
    * 선점된 자원들은 그 프로세스가 기다리고 있는 자원들의 리스트에 추가된다.
    * 프로세스는 자신이 요청하는 새로운 자원 + 예전에 갖고 있던 자원까지 모두 얻을 수 있을 때만 재시작 할것이다.
  * `Circular Wait`
    * 모든 자원타입에 전체적인 순서를 부여(impose)한다.
    * 각 프로세스가 열거된 순서대로(order of enumeration) 오름차순으로 자원을 요구한다
* 제한(restraints)는 최소 한개의 데드락 필요조건이 성립되지 않으면, 데드락이 일어나지 않음을 보장한다.
* 데드락 예방의 가능한 부작용은 다음과 같다.
  * 낮은 장치 이용률
  * 시스템 총처리량 감소
* 이에 대한 대안이 바로 `Deadlock Avoidance` 다.



---

### Deadlock Avoidance(DA)





