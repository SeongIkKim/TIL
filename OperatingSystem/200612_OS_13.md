OS 정리 13
========

Chapter 7 - Deadlocks
--------------

### Deadlock Problem

* 대기중인 모든 프로세스들이 _자원을 holding한 상태_ 이며 다른 프로세스가 holding하고 있는 _자원을 얻기를 기다리고있는_ 상태
* 예시 1
  * 시스템은 두개의 테이프 드라이브를 가지고 있다.
  * P1과 P2는 각각 하나의 테이프 드라이브를 가지고 있으며 나머지 한개를 필요로 한다.
* 예시 2
  * 1로 초기화된 세마포어 A와 B가 있다
    * P0은 P1을, P1은 P0을 wait한다
* 예시 : 다리건너기
  * 교통은 _한 방향_ 으로만 이루어진다.
  * 다리의 각 섹션을 _resource_ 로 볼 수 있다.
  * 교착상태가 일어나면, 한 차가 뒤로 물러서면 해결할 수 있다. (리소스를 선점하고 롤백하는것)
  * 각 차들은 교착상태가 일어나면 물러서야 할 수도 있다.
  * __기아__ 가 일어날 수도 있다.

---

### System Model

* m개의 자원(자원 타입 : CPU 사이클, 메모리 공간, 입출력 장치 등)이 있을 때
* 각 자원 R은 __여러개의 인스턴스 W__ 를 가지고 있다.
* 각 프로세스는 다음에 따라 자원을 사용할 수 있다.
  * 요청 : 요청이 즉시 허용되지 않으면 요청 프로세스는 자원을 얻을 때까지 대기해야한다.
  * 사용 : 프로세스는 자원에 대해 작업을 실행할 수 있다.
  * 방출 : 프로세스는 자원을 방출한다.



---

### Deadlock Characterization

* 아래는 데드락의 특징이지, 조건이 아니다.
* 데드락은 네 개의 조건을 동시에 성립할 때 발생할 수 있다.
  * `Mutual exclusion`  상호배제 : 한번에 한개의 프로세스만 자원을 사용할 수 있다.
  * `Hold and wait` 점유하며 대기: 프로세스는 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유한 자원을 추가로 얻기 위해 반드시 대기해야한다.
  * `No preemption` 선점 불가 : 자원은 강제적으로 방출될 수 없고, 점유하고 있는 프로세스가 태스크를 종료한 후 _그 프로세스에 의해 자발적으로만_ 방출될 수 있다.
  * `Circular wait` 순환 대기 : 대기하고 있는 프로세스집합에서 각 프로세스는 순환적으로 다른 프로세스의 자원을 기다리고있다.



#### Resource-Allocation Graph

* 데드락은 `system resource-allocation graph` 라고하는 _directed graph_로 보다 정확하게 기술할 수 있다.
* 정점 집합 V(Vertex)는 두가지 타입으로 나뉜다.
  * P  : 시스템 내 모든 활성 _프로세스_ 의 집합
  * R : 시스템 내 모든 _자원 타입_ 의 집합
* 간선 집합 E(Edge)는 두 가지 타입으로 나뉜다.
  * 요청(request) 간선 : P->R 간선
  * 할당(assignment) 간선 : R->P 간선
* *자원 내 인스턴스는 자원에 있는 점으로 표현된다.

<center><img src="./img/Example of a Resource Allocation Graph.png" style="width:60vw;"></img></center>

* 위와 같은 그래프가 있다고 할때, 데드락이 일어나는가? (선점불가라고 가정한다)
* cycle을 포함하지 않으므로 교착상태가 존재할 수 없다.

<center><img src="./img/Resource Allocation Graph with a Deadlock.png" style="width:60vw;"></img></center>

* _R1은 하나의 인스턴스만을 가지고 있다._
* 위의 그래프에서는 cycle이 완성되었으므로, 데드락이 발생한다.

<center><img src="./img/Resource Allocation Graph With A Cycle But No Deadlock.png" style="width:60vw;"></img></center>

* _R1은 두개의 인스턴스를 가지고 있다._
* 그러나 cycle이 있다고 해서 __반드시 데드락이 생기는 것은 아니다.__



* 따라서,
  *  그래프에 __cycle이 없으면__ , __데드락이 발생하지 않는다__ 
  * 만약 그래프에 __cycle이 있다면__ ,
    * 자원 타입에 인스턴스가 _하나밖에_ 없다면, __데드락이 일어난다__
    * 자원 타입에 인스턴스가 _여러 개_ 있다면, __데드락이 일어날 가능성이 있다__



---

### Methods for Handling Deadlocks

1. _시스템이 데드락에 빠지지 않도록_ 보장한다.
   * _데드락을 피하거나 예방하기 위한 프로토콜_ 을 사용한다.
   * __데드락 예방, 데드락 회피__
2. 시스템이 데드락에 돌입하는 것을 허용한 뒤 회복시킨다
   * __데드락 탐지, 데드락 회복__
3. 문제를 무시하고, 데드락이 시스템에서 결코 발생하지 않는 척 한다.
   * UNIX와 Windows를 포함한 대부분의 OS에서 사용된다.
   * 이 경우 데드락을 해결하는 것은 프로그램을 짜는 개발자에게 달려있다.



---

### Deadlock Prevention

* 앞의 네가지 필요조건 중 최소 하나가 성립되지 않도록 보장하여 데드락을 예방한다.
* 요구조건이 성립될 수 있는 방법을 제한한다.
  * `Mutual Exclusion` - _공유 가능한 자원_ 들에는 성립될 필요가 없지만, _공유 불가능한 자원_ 들에 관해서는 반드시 성립해야한다.
  * `Hold and Wait` - _프로세스가 자원을 요청할 때, 다른 자원을 점유하고 있지 않아야 한다._ 
    * 프로세스가 수행 전에 자신의 모든 자원을 요청하여 할당받도록 한다.
    * 프로세스가 자원을 전혀 갖고 있지 않을때만 자원을 요청할 수 있도록 허용한다.
    * 많은 자원들이 할당된 후 오랫동안 사용되지 않기 때문에, 자원 이용률이 낮다 ; 여러 개의 인기자원을 필요로 하는 프로세스는 최소한 하나의 자원의 계속 다른 프로세스에 할당되어있어 기아문제가 발생할 수 있다.
  * `No Preemption`  - 이미 할당된 자원이 선점되지 않아야한다.
    * 만약 어떤 자원을 점유하고 있는 프로세스가 즉시 할당받을 수 없는 다른 자원을 요청하면, 현재 점유하고 있는 모든 자원들은 방출된다.
    * 선점된 자원들은 그 프로세스가 기다리고 있는 자원들의 리스트에 추가된다.
    * 프로세스는 자신이 요청하는 새로운 자원 + 예전에 갖고 있던 자원까지 모두 얻을 수 있을 때만 재시작 할것이다.
  * `Circular Wait`
    * 모든 자원타입에 전체적인 순서를 부여(impose)한다.
    * 각 프로세스가 열거된 순서대로(order of enumeration) 오름차순으로 자원을 요구한다
* 제한(restraints)는 최소 한개의 데드락 필요조건이 성립되지 않으면, 데드락이 일어나지 않음을 보장한다.
* 데드락 예방의 가능한 부작용은 다음과 같다.
  * 낮은 장치 이용률
  * 시스템 총처리량 감소
* 이에 대한 대안이 바로 `Deadlock Avoidance` 다.



---

### Deadlock Avoidance(DA)

* 자원이 어떻게 요청될 지에 대한 추가적인 정보를 미리 시스템이 제공하도록 요구한다.
* DA의 간단하면서 가장 유용한 모델은 다음의 요구조건을 가진다.
  * 각 프로세스가 __자신이 필요로하는 각타입의 자원 마다 최대 개수__를 선언하는 것
* 데드락 회피 알고리즘은 __순환대기 상태__ 가 발생하지 않도록 _자원 할당 상태_ 를 동적으로 검사한다.
* 자원할당 상태는 가용 자원의 수, 할당된 자원의 수, 그리고 프로세스들의 최대 요구 개수에 의해 정의된다.

<center><img src="./img/Resource Allocation State.png" style="width:60vw;"></img></center>

* 데드락을 회피하기 위해 시스템은 safe state나 unsafe state라는 추가 정보를 보내는데, safe state는 데드락으로 돌입할 가능성이 전혀 없다는 것을 의미한다.
* 자원 요구 갯수를 보고 만약 이것을 할당해주었을 때 circular-wait로 돌입할 수 있으면 자원을 주지 않고, 그렇지 않으면 자원을 준다.



#### Safe State

* 프로세스가 가용한 자원을 요청했을 때, 시스템은 즉각 할당해도 시스템이 안전 상태에 머무르는 지 판단해야한다.
* 모든 프로세스에 대해 안전순서가 존재하면 시스템이 안전 상태에 있다고 판단한다.
* 특정 순서 <P1, P2, ... Pn>이 안전하다는 말은 모든 Pi에 대해 그 [Pi가 요청하는 자원]을 [시스템에 현재 가용한 자원 + i보다 이전에 종료된 프로세스들이 반납하는 자원]으로 만족시켜 줄 수 있음을 뜻한다.
  * Pi가 당장에 수행되지 못하면, Pj(Pi 이전의 프로세스)가 반납하여 자원이 가용해질 때까지 기다린다.
  * Pi가 종료되면 Pi 이후의 프로세스들도 동일한 과정을 반복한다.

* 시스템이 안전상태라면 -> 데드락이 일어나지 않는다.
* 시스템이 불안전상태라면 -> 데드락의 가능성이 있다.
* 데드락 회피는 -> 시스템이 불안전 상태에 진입하지 않도록 보장해준다.



#### Resource Allocation Graph Algorithm

* _Claim edge(예약 간선)_ Pi->Rj는 프로세스 Pi가 Rj에게 미래에 자원을 요청할 것이라는 의미이다.
* 예약 간선은 프로세스가 직접적으로 자원을 요구할 때 _request edge(요구 간선)_ 으로 전환된다.
* 프로세스가 점유하고 있던 자원이 방출되면, _assignment edge(할당 간선)_ 이 예약 간선으로 전환된다.
* 시스템에서 자원은 반드시 미리 예약되어야 한다. 즉, 프로세스 Pi가 실행되기 전 프로세스의 모든 예약 간선들이 자원할당 그래프에 표시되어야 한다.

<center><img src="./img/Resource Allocation Graph Edges.png" style="width:60vw;"></img></center>

* 왼쪽부터 예약 간선, 요구 간선, 할당 간선이다.



* 알고리즘
  * 프로세스 Pi가 자원 Rj을 요청하고 있다고 가정하자.
  * 요청 간선(Pi->Rj)이 할당간선(Rj->Pi)으로 변환해도 자원 할당 그래프에 __cycle을 형성하지 않을때만__ 요청이 받아들여질 수있다.
  * 우리는 `cycle-detection algorithm` 을 통하여 안전성을 체크할 것이다.
  * 만약 _사이클이 존재하지 않는다면_ 자원할당을 해도 시스템은 _안전상태_ 에 있다.
  * 만약 _사이클이 발견된다면_ 그 할당은 시스템을 _불안전상태_ 에 빠뜨릴 위험이 있다. 따라서 Pi는 대기해야 한다.

<center><img src="./img/Resource Allocation Graph For Deadlock Avoidance.png" style="width:60vw;"></img></center>

* 위의 그래프에는 cycle이 없기 때문에 __안전상태__ 이다.
* P1을 먼저 수행하고 P2를 수행할 수 있다. P1을 끝내고 나면 R1과 R2 모두 가용해지기 때문이다.

<center><img src="./img/Unsafe State In Resource-Allocation Graph.png" style="width:60vw;"></img></center>

* 위의 그래프에는 cycle이 존재하기 때문에 __불안전상태__ 이다.
* P2를 먼저 수행하려고 R2-P2로 할당 간선을 만드는 순간 cycle이 생겨버리므로 불안전 상태로 돌입한다. 따라서 데드락 회피에서는 P2가 P1보다 먼저 R2를 할당받을 수 없다. 위와 같은 방식으로 cycle이 형성된 그래프에서는 P1가 먼저든 P2가 먼저든 안전순서가 아니다.



* 이러한 자원할당 그래프는 _instance가 여러개 있을경우 사용불가_ 한 알고리즘이므로, 다른 알고리즘을 찾아 볼 것이다.



#### Banker's Algorithm

* 데드락을 회피하는 알고리즘이다.
  * 인스턴스가 여러개 있어도 사용가능하다.
  * 자원할당 그래프보다는 덜 효율적이다.
  * 은행에서 사용되는 방식이라서 이런 이름이 붙었다.

* 다음을 가정한다.
  * 각 프로세스는 프로세스가 시작할 때 프로세스가 가지고 있어야 할 자원의 최대 개수를 자원종류마다 _미리 신고_ 한다.
  * 프로세스가 자원을 요구할 때, _기다려야 할 수도 있다._ (시스템이 자원을 주려고 할 때 1. 자원을 준다면 불안전상태에 돌입하거나 2. 가용한 자원이 부족할 때 기다리게 한다.)
  * 프로세스가 모든 자원을 얻게 되었을 때 _유한한 시간만큼 자원을 사용하고 반납_ 해야한다.
* 두 가지의 하위 알고리즘을 포함한다.
  * __Safety Algorithm__
  * __Resource-Request Algorithm__

* 은행원 알고리즘의 자료구조는 다음과 같다.

  * n : 프로세스 개수, m : 자원타입의 개수
  * `Available` : 가용한 자원의 개수를 나타내는 벡터, length가 m이다.
    * Available[j] = k이면 Rj 자원을 k개의 인스턴스만큼 사용할 수 있다는 말이다.
  * `Max` :각 프로세스가 최대로 필요로 하는 자원의 개수를 나타내는 행렬로, n x m 행렬이다.
    * Max[i,j] = k면 프로세스 i가 자원 j의 인스턴스를 최대 k개까지 요구할 수 있다는 말이다.
  * `Allocation` : 각 프로세스에게 현재 나가있는 자원의 개수를 나타내는 행렬로, n x m 행렬이다.
    * Allocation[i,j] = k 이면 프로세스 i가 자원 j의 인스턴스를 k개만큼 사용하고 있다는 말이다.
  * `Need` : 각 프로세스가 향후 요청할 수 있는 자원의 개수를 나타내는 행렬로, n x m 행렬이다.
    * Need[i,j] = k라면 프로세스 i가 향후 자원 j를 k개만큼 더 요청할 수 있다는 말이다.
    * Need(앞으로 요청할 수 있는 숫자) = Max(최대 사용가능 숫자) - Allocation(이미 할당받은 숫자)
  * Available과 Need의 차이
    * Available은 시스템의 입장에서 남은 자원 인스턴스의 총 숫자이고, Need는 프로세스의 입장에서 더 받을 수 있는 자원의 개수이다.

* 프로세스 Pi에 대한 Resource Request Algorithm

  * 자원 요청을 안전하게 들어줄 수 있는지 검사하는 알고리즘이다.
  * Request i [j] = k 라면 프로세스 i가 자원 j의 인스턴스를 k개만큼 요구한다는 것을 의미한다.

  

  * 1. 만약 __Request i [j]가 Need보다 작거나 같으면__ step2로 간다. 그렇지 않으면 시스템에 있는 개수보다 더 많이 요구했으므로 오류로 처리한다.

  * 2. Request가 Available보다 작으면 3단계로 간다. 그렇지 않으면 요청한 자원이 당장은 없으므로 프로세스 i는 기다려야한다.

  * 3. 마치 시스템이 프로세스 i에게 요청한 자원을 할당해준 것처럼 시스템 상태정보를 아래와 같이 바꿔본다.

  * - Available = Available - Request
    - Allocation = Allocation + Request
    - Need = Need - Request

  * 4. 안전성 알고리즘을 돌려본다.

  

  * 만약 이렇게 바뀐 상태가 _안전하다면_  -> 프로세스 i에게 자원을 할당해준다.
  * _안전하지 않다면_ -> 위의 자원 할당 상태는 원상태로 복원되고, 프로세스 i는 요청이 만족되기까지 기다려야한다.

* Safety Algorithm

  * 시스템이 safe상태인지 아닌지 확인하는 알고리즘이다. -> 최대 (mxn^2)개의 연산이 필요하다.

    

    1. Work와 Finish는 각각 크기가 m과 n인 벡터이다. Work는 Available로, Finish는 i=0~n-1까지 False로 초기값을 준다.
    2. 아래 두 조건을 만족시키는 i를 찾는다. 만약 그런 i가 없으면, 4단계로 바로 간다.
       * Finish[i] = false
       * Need <= Work
    3. Work = Work + Allocation이고, i는 끝났다고 한 뒤 step 2로 돌아간다.
    4. 만약 Finish [i]가 모든 i 대해서 true이면 안전 상태이다.

  * 해결할 수 있는 프로세스부터 먼저 해결해서 자원을 돌려받고, 더 큰 자원을 요구하는 프로세스에게 다시 자원을 줘서 해결하고 그 프로세스가 가진 자원을 돌려받고, 이런 식으로 쭉 반복해서 결과적으로 모두 끝낼 수 있으면 안전순서이다.

  * 예시는 슬라이드를 참조한다.



---

### Deadlock Detection



#### Single Instance of each Resource Type 각  자원타입에 인스턴스가 하나인 경우

* 자원할당 그래프를 이용하여 어떻게 데드락을 탐지하는가?

* 자원할당 그래프를 변형한 __wait-for(대기) 그래프__ 를 이용한다

* - 노드들은 프로세스를 의미한다.
  - Pi->Pj 간선은 Pi가 Pj를 기다리고 있다는 것을 의미한다

* _그래프에서 cycle을 찾도록_ 주기적으로 알고리즘을 호출한다

* - 만약 cycle이 있으면 -> deadlock이 발생한다.

* 알고리즘이 그래프에서 사이클을 찾는것은 n<sup>2</sup>번의 연산을 필요로 한다.

* - 이 때 n은 그래프 정점 개수이다.

<center><img src="./img/Resource-Allocation Graph and Wait-for Graph.png" style="width:60vw;"></img></center>

* 자원할당 그래프에 대응하는 대기 그래프를 위와 같이 그릴 수 있다.



---

### Recovery from Deadlock

* 탐지 알고리즘이 데드락이 존재한다는 것을 알아차렸다면, 다음의 대안을 시도할 수 있다.
  * 운영자(operator)에게 데드락이 발생했다고 통지해 운영자가 수작업으로 처리하도록 한다
  * `Process Termination`
    * 한개 이상의 프로세스를 중지(abort)시켜서 순환 대기상태를 깬다
  * `Resource Preemption`
    * 데드락 상태에 있는 하나 이상의 프로세스들로부터 자원을 선점한다.



#### Process Termination

1. 모든 데드락 상태의 프로세스를 중지시킨다.
2. 데드락 사이클이 제거될 때 까지 프로세스를 하나씩 중지시킨다. 이 경우 매번 아직도 교착상태에 있는지 확인해야 하므로 상당한 오버헤드가 일어난다.

* 어떤 프로세스를 중지시킬 지 정하는 기준은 무엇인가?
  * _프로세스의 우선순위_
  * _지금까지 프로세스가 얼마나 수행되었는지, 완료하는데까지 얼마나 더 걸리는지_
  * _프로세스가 사용한 자원 타입과 수_
  * _프로세스가 종료하기 위해 더 필요한 자원의 수_
  * _얼마나 많은 수의 프로세스가 종료되어야 하는지_
  * _프로세스가 대화형인지 일괄처리형인지_



#### Process Preemption

* 자원 선점에 있어서 다음 세가지 사항을 고려한다.
  1. __희생자 선택__ - 비용을 최소화하기 위해 어느 자원과 프로세스들이 선점될 것인지 순서를 정한다.
  2. __롤백__ - 안전상태로 되돌아가서, 프로세스를 재시작한다. 그렇지만 이 방식은 롤백을 위한 모든 프로세스들의 상태에 대해서 많은 정보를 평소에 저장해두고 있어야한다.
  3. __기아상태 __ - 기아상태가 발생하지 않는다는 것을 어떻게 보장할 것인가? 즉, 자원이 동일한 프로세스로부터 항상 선점되지 않는다는것을 어떻게 보장할 것인가?

