OS 정리 14
========

Chapter 8 - Memory Management
--------------

### Background

* CPU 스케줄링의 결과로, 우리는 다음 두개를 개선시킬 수 있다.
  * CPU 사용률
  * 컴퓨터의 사용자에 대한 반응 속도
* 이 성능 향상을 실현하기 위해서 우리는 _주 메모리에 여러개의 프로세스가 올라와 있도록_ 관리해야한다.
* 프로그램은 실행되기 위하여 반드시 메모리에 올라와서 프로세스들 사이에 위치해야한다.
  * 각 프로세스들은 _분리된 메모리 공간_ 을 가지고 있다. 이를 위해 특정 프로세스만 접근할 수 있는 합법적 메모리 주소 영역이 설정되어있어야 한다.
  * `Base register` 와 `limit register` 는 물리 메모리에서 프로세스의 주소영역을 결정하는데에 필요하다.
  * 기준 레지스터는 가장 작은 합법적인 물리 메모리 주소값을 저장한다( 영역의 최소 주소를 가리킨다)
  * 상한 레지스터는 프로세스 주소 공간의 크기를 저장한다. (영역의 offset을 저장함으로써 영역 상한을 가리킨다)

<center><img src="./img/A base and a limit register.png" style="width:60vw;"></img></center>



#### H/W address protection with base and limit register

* __메모리 공간 보호__ 는 CPU 하드웨어가 사용자모드에서 만들어진 모든 주소와 레지스터(기준/상한)을 비교함으로써 이루어진다.
* 사용자 모드에서 실행되는 프로그램에 의해 운영체제의 메모리공간이나 다른 사용자  프로그램의 메모리공간으로__불법적인 메모리접근__ 이 일어나면  OS는 이를 치명적인 에러로 간주하고 __trap__ 을 발동시킨다.

<center><img src="./img/addressing error.png" style="width:60vw;"></img></center>



#### Input queue

* 프로그램은 원래 이진 실행 파일 형태로 __디스크__ 에 저장된다.
  * 이 프로그램이 실행되기 위해서는 주 메모리로 올라와서 "프로세스"가 되어야 한다.
  * 사용하는 메모리 관리기법이 무엇이느냐에 따라서, 프로세스는 _실행하는 동안 디스크와 주 메모리 사이를 왔다갔다 할 수 있다_.
  * 디스크에서 주 메모리로 들어오기를 기다리고 있는 프로세스들의 집합은 `input queue` 를 형성한다.
* `input queue` - 디스크에서 주 메모리로 들어오기를 기다리고 있는 프로세스들의 집합



#### Logical vs Physical Address Space

* 프로그램에 의해 생성된 모든 논리 주소 집합을 논리주소공간_logical address space_ 라고 하며, 이 논리 주소에 상응하는 모든 물리 주소 집합을 물리주소공간_physical address space_ 라고 한다.
  * 논리 주소 - CPU에 의해 만들어지며, `virtual address` 로도 불린다.
  * 물리 주소 - 메모리유닛에 의해 보여지는 주소
* 논리주소와 물리주소는 컴파일 타임에는 동일하다.
* 논리(가상) 주소와 물리주소는 실행시간바인딩 _execution-time address-binding_ 기법과 적재시바인딩 _load-time address_ 에서는 다르다.



* 이를 단순하게 설명하면 다음과 같다.
  * 우리가 코드를 짜서 컴파일 했을 때(logical address), 프로그램은 순차적인 주소로 만들어져 있으므로 정확히 어느 라인에서 문제가 생겼는 지 체크할 수 있다.(ex- 코드의 48번라인에 세미콜론이 빠져있다던지)
  * 그런데 실제로 메모리에 저장될 때는, bound와 limit 사이에 무작위로 흩뿌려져서 코드가 저장된다.
  * OS는 이를 mapping 시킨다. 논리주소를 물리주소에 맞게 알아서 변환한다음 저장시키므로, 해당 주소 공간 내에서 우리는 메모리 주소 내에 어떤 순서로 들어가 있을지 예측할 수 없다. 이런 방식을 paging이라고 하고, 이후에 배울 것이다.
  * 따라서, 여기서 기억할 점은 논리주소와 물리주소가 결과적으로 달라진다는 점이다.



#### Address Binding : Instructions and Data to Memory

* 메모리 주소공간에서 명령어와 데이터의 바인딩은 바인딩이 이루어지는 시점에 따라 세가지로 구분된다.
  * `Compile time` : 프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 미리 알 수 있으면 컴파일러는 __absolute code__ 를 생성할수 있다.  그러나 만일 이 위치가 변경되면 재컴파일해야한다.
  * `Load time` : 프로세스가 메모리 내 어디에 올라오게 될 지를 컴파일 시점에서 알지 못하면 컴파일러는 일단 이진 코드를 __relocatable code__ 로 만든다.
  * `Execution time` : 프로세스가 실행하는 중간에 메모리 내의 한 세그먼트로부터 다른 세그먼트로 옮겨질 수 있다면, 바인딩이 실행시간까지 허용되었다고 할 수 있다.
    * 이 방식은 주소 맵에 대한 특별한 하드웨어적 지원이 필요하다(예 - 기준, 상한 레지스터 등)



#### Memory Management Unit(MMU)

* 논리주소와 물리주소를 연결해주는 하드웨어 장치이다.
* `MMU scheme` 에서, 재배치 레지스터의 값은 주소가 메모리로 보내질 때 사용자 프로셋에 의해 생성된 모든 주소에 대해 더해진다.
* 사용자 프로그램은 _논리주소_ 를 담당한다.
* _진짜 물리주소_ 는 결코 알수 없다.

<center><img src="./img/Dynamic relocation using a relocation register.png" style="width:60vw;"></img></center>

* 예를 들어, 재배치 레지스터의 값이 14000이라면 프로세스가 346번지를 액세스할 때 실은 주메모리의 14346(346 + 14000)번지를 액세스하게 된다.
* 사용자 프로그램 내에서는 346번지에 대한 포인터를 가지고 레지스터에 저장, 연산, 비교 등의 온갖 일을 다하지만, 메모리에 참조하는 순간 기준 레지스터(여기서는 재배치 레지스터)를 기준으로 재배치된다.



---

### Swapping

* __프로세스__ 는 일시적으로 주 메모리에서 보조 메모리(ex- 하드디스크)로 내려갔다가 다시 되돌아 올 수 있다.
  * 이를 swap in, swap out이라고 일컫는다.
* `Backing store` 
  * 모든 유저의 모든 메모리 이미지 복사본을 다 수용할 수 있을 만큼 충분히 큰 고속 디스크
  * 이러한 메모리 이미지들에 대해 직접 액세스를 제공해야만한다.
* `Roll out, roll in`  : 스와핑은 스케줄링 알고리즘의 우선순위에 따라 달라진다. 낮은 우선순위의 프로세스는 높은 우선순위 프로세스가 로드되어서 실행될 수 있도록 스왑 아웃된다.
* 스왑 시간의 대부분은 __transfer time__ 이다.
* 총 transfer time은 스왑되는 메모리 량에 정비례한다.
* UNIX, Linux, Windows 등의 많은 시스템에서 수정된 스와핑을 채택하고 있다.

<center><img src="./img/Schematic View of Swapping.png" style="width:60vw;"></img></center>

* 주 메모리 공간이 충분하지 않으면, __Dispatcher__ 는 프로세스를 _backing store_ 에 있는 _input queue_ 로 스왑아웃시킨다.
* 주 메모리 공간이 확보되면, __Dispatcher__ 는 프로세스를 backing store에서 준비 큐로 불러들인다.



---

### Contiguous Allocation

* 주 메모리는 일반적으로 두 개의 부분으로 나눠진다.
  * _메모리에 상주하는 OS를 위한 것_ , _interrupt vector_ 와 함께 _하위 메모리_ 에 상주한다.
  * _사용자 프로세스_ 는 상위 메모리에 상주한다.
* __`Contiguous Allocation`연속적 할당__
  * 각 프로세스는 메모리 내에서 연속된 메모리공간을 하나씩 가진다.
  * 재배치 레지스터는 유저 프로세스를 서로로부터 보호하고, OS의 코드와 데이터를 변경하는것을 막기 위해 사용된다.
    * 재배치 레지스터는 _가장 작은 물리주소값_ 을 저장하고있다.
    * 상한(한계) 레지스터는 논리주소의 범위 값을 저장한다 - _각각의 논리주소는 상한 레지스터보다 더 작아야한다_ 

<center><img src="./img/Example of contiguous allocation.png" style="width:60vw;"></img></center>

* 각 프로세스들은 연속된 공간을 가진다. 파란색 부분은 empty spae이고, 만약 P4가 들어온다면 저 공간으로 들어오게 될 것이다.



* Protection with limit and relocation register
  * 각 논리주소는 상한 레지스터보다 작아야한다.
  * MMU는 논리주소를 메모리로 보낼 때 재배치레지스터의 값을 동적으로 더해서 매핑시킨다.



* `Hole` 자유공간 : __사용가능한 메모리 공간__ ; 메모리 곳곳에 다양한 사이즈로 흩어져있다.
* OS는 __allocated partition__ 과 __free partitions(hole)__ 에 대한 정보를 유지하고 있다. (어떤 부분이 사용되고 있고, 어떤 부분이 사용되지 않는가를 파악할 수 있는 테이블을 유지하고있다)
* 프로세스가 시스템에 들어오면, OS는 그것을 수용할 수 있을 정도로 충분히 큰 hole로부터 메모리를 할당한다.

* __Dynamic Storage Allocation Problem 동적 메모리 할당 문제__ 
  * 자유 공간의 리스트에서 n 크기의 블록 요청을 어떻게 만족시킬 것인가?

* __최초적합_First-fit___ : 들어갈 수 있을만큼 충분히 큰 __첫번째__ hole을 사용

* __최적적합_Best-fit___ : 들어갈 수 있을만큼 충분히 큰 hole중 __가장 작은 __ hole을 사용

* - 크기순으로 정렬된 것이 아니면 모든 리스트를 다 훑어봐야한다.
  - 가장 작은 잔여공간만을 남겨둔다.

* __최악적합_Worst-fit___ : __가장 큰__ hole을 사용

* - 크기 순으로 정렬된 것이 아니면 모든 리스트를 다 훑어봐야 한다.
  - 할당하고 남게된 hole이 충분히 커서, 이것이 다른 프로세스들을 위해서 유용하게 사용될 수 있다.

* 스피드와 저장공간 사용측면에서 최초/최적적합이 최악적합보다 낫다.



#### Fragmentation

- __External Fragmentation 외부 단편화__ - 전체 메모리공간이 요청을 만족시키지만, 연속적이지는 않다.

- - 이런식으로 군데군데 메모리를 사용하면 중간에 끼어있는 빈 공간들이 프로세스가 들어가는 크기는 못되고, 결과적으로는 너무 많은 빈 공간이 생겨서 아주 비효율적일수있다.
  - 메모리가 너무 많은 수의 매우 작은 조각들로 단편화되어 있는 것이다.

- __Internal Fragment 내부 단편화__ - 요청공간보다 조금 더 많은 메모리를 할당해야 할수도 있다.

- - 이 사이즈 차이는 분할된 조각 내부에 존재하는, 현재 사용되고 있지 않은 메모리이다.

- 외부 단편화를 `compaction` 으로 줄일수 있다. ex-디스크조각모음

- - 사용가능한 메모리들을 _전부 모아 하나의 블록으로 만들기 위해_ 메모리를 셔플한다.
  - 압축은 재배치가 수행시간에 동적으로 이루어지는 경우에만 가능하다.
  - 프로세스를 계속 옮겨야하므로 당연히 복사 시간이 오래 걸린다.



---

### Paging - 메모리 관리 기법의 일종

- 다음을 허용한다.

- - 물리주소가 애초에 __noncontiguous__ 여도 상관없다
  - 프로세스는 물리주소가 가용할때만 물리주소에 올라가게 된다.

- __물리주소__ 를 __`frame`__ 이라는 __정해진 사이즈의 블록__ 으로 나눈다. 사이즈는 일반적으로 2의 배수이다.

- __논리주소__ 를 __`page`__ 라고 하는 __같은 사이즈의 블록__ 으로 나눈다.

- 모든 가용한 프레임의 목록을 추적해둔다.

- n 사이즈의 페이지가 필요한 프로그램을 실행할 때, n사이즈의 프레임을 찾아서 프로그램을 메모리에 적재한다.

- 논리주소를 물리주소로 변환시키기 위해 `page table` 을 만든다.

- __외부 단편화는 없지만 내부 단편화는 존재한다.__



* 풀이
  * 물리주소를 여러 조각의 페이지로 나누어놓고, 프로세스가 요구하는만큼 페이지를 나누어서 저장한다.
  * 예를들어 process가 40페이지를 요구한다면, 메모리는 비어있는 e1에서 10페이지를 주고, e2에서 15페이지를 주고, e3에서 15페이지를 줘서 프로세스를 여러 공간에 할당할 수 있다.
  * 대신에 내부 단편화가 발생된다. 할당은 항상 프레임의 정수배로 할당되기때문에, 프로세스가 더 필요한 공간이 한 프레임보다 더 작다면 프레임이 남는, 내부단편화가 발생한다. 이런 걸 보면 페이지 크기를 줄일수록 내부단편화를 줄일수 있다고 생각할 수있는데, 페이지 사이즈가 너무 작아지면 페이지 테이블이 커지므로 페이지 테이블이 차지하는 공간이 낭비된다. 적절한 중간선을 찾는것이 필요하다.
  * 그리고 내부 단편화가 발생하더라도 페이지 크기가 충분히 작으므로, 이전에 남던 단편화로인한 유휴공간보다 훨씬 더 적은 공간낭비가 발생한다.



#### Address Translation Scheme

* CPU에 의해 생성되는 논리주소는 아래와 같이 나뉜다

* - __Page number (p)__ - 물리주소 내 각프레임의 기준 주소를 담아놓은 페이지테이블의 인덱스로서 사용된다.
  - __Page offset (d)__ - 페이지 넘버를 가지고 페이지테이블에서 매칭한 기준주소에 페이지 변위를 더하면 메모리장치로 사상될 물리 주소가 된다.

* 만약 논리 주소공간이 2<sup>m</sup>이고, 페이지 사이즈가 2<sup>n</sup>이면
  * 논리 주소의 상위 m-n 비트는 페이지 번호를 나타내고, 하위 n비트는 페이지 변위를 나타낸다.

<center><img src="./img/Logical Address in Page.png" style="width:60vw;"></img></center>



<center><img src="./img/Address Translation Architecture.png" style="width:60vw;"></img></center>

* CPU가 페이지 번호를 말해주면, 페이지 테이블에서 해당 페이지 번호를 이용해 어떤 물리주소로 갈 것인지를 알려준다.
* 페이지 테이블은 물리주소에서 각 페이지의 기준주소를 가지고 있다.
* 페이지 테이블은 각 프로세스마다 형성된다.

<center><img src="./img/Paging Example.png" style="width:60vw;"></img></center>

* 위와 같이 페이지 0~3까지 사용하는 프로세스가 있을 때, 페이지 테이블에서 각 페이지당 어느 물리주소로 연결되어있는지를 알려준다.











