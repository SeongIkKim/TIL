

Chapter 9 - Virtual Memory Management
--------------

### Background

#### Virtual Memory

* 유저의 논리메모리를 물리 메모리로부터 분리하는 개념이다.
  * 실행을 위해서 __프로그램의 일부분만__ 메모리에 올라오도록 한다.
  * 물리 주소 공간보다 __훨씬 더 큰__ 논리 주소공간을 가질 수 있도록 해주는 개념이다.
  * 주소공간들은 여러 프로세스들간에 _공유될 수 있다_ .
  * _더 효과적인 프로세스 생성_ 을 돕는다.
* 가상 메모리는 다음을 통해 구현된다.
  * __`Demand Paging`__
  * __`Demand segmentation`__

<center><img src="./img/Virtual Memory.png" style="width: 60vw;"></img></center>

* 논리 메모리와 물리 메모리의 분리는 프로그래머가 __매우 큰__ 가상 메모리를 가질 수 있게 해준다.
* 프로그래머는 더이상 가용한 물리메모리의 양을 신경 쓸 필요가 없다.
* `MMU` 는 가상주소를 물리주소로 매핑해준다.
* 위 그림에서, 오른쪽 원통의 박스 하나하나하나가 하나의 페이지이다.
* 8기가의 램밖에 없는데 100기가의 메모리를 요구하는 프로세스가 있다면, 다른 프로세스로부터 페이지를 뺏어서 마치 100기가가 있는 것 처럼 가상 메모리를 만들면 된다.



#### Virtual-address Space

Virtual address space

<center><img src="./img/Virtual address space.png" style="width: 30vw;"></img></center>

* 가상 주소공간은
  * _프로세스가 메모리에 저장되는 논리적인 모습이다._
  * 일반적으로 특정 논리 주소(보통 0번지)에서 시작한다.
* 프로세스는 _연속적(contiguous) 메모리_ 로 이루어진다.
* 프로세스는 _네 부분_ 으로 이루어진다.
  * 코드, 데이터, 힙, 스택
* 힙은 주소공간 위쪽으로 확장된다.
* 스택은 주소공간 아래쪽으로 확장된다.
* 힙과 스택 사이의 커다란 빈 공간도 가상 주소 공간의 일부이나, 힙이나 스택이 확장해야만 실제 물리 페이지를 요구하게 된다.



---

### Demand Paging

* 가상 메모리 관리 전략이다.
* __페이지는 프로그램 실행 도중 그것들이 필요할 때에만 메모리로 올라온다__ -> `dynamic loading`
  * 입출력 요구 감소
  * 필요 메모리 감소
  * 더 빠른 반응속도
  * 더 많은 사용자 수용 가능
* 페이지가 필요하다면, 참조한다
  * 유효하지 않은 참조라면 참조를 중단한다.
  * 메모리에 존재하지 않는다면 메모리로 가져온다.



#### Demand-paging system with swapping

* _요구 페이징 시스템_ 은 프로세스가 보조 메모리(통상 디스크)에 존재한다는 점에서 _스와핑을 이용한 페이징 시스템_ 과 비슷하다.
* 요구 페이징에서 프로세스는 하나의 연속된 주소공간보다는, _페이지들의 연속_ 이라고 할 수 있다.
* 프로세스가 __생성__ 된다면, __Lazy Swaaper(pager)__ 가 사용된다.
  * 페이지가 필요할 때까지 페이지를 스왑 인 해오지 않는다.
  * __pure demand paging__ : 어떤 페이지도 가져오지 않은 상태에서 프로세스를 실행하는 것. 항상 페이지 부재 트랩이 발생한다.



#### Valid-Invalid Bit

* 요구 페이징 시스템에서, 일부 페이지들은 메모리에 있고 나머지 페이지들은 디스크에 존재한다. 따라서 이 두가지 경우를 구별할 하드웨어적인 서포트가 필요하다.

* 각 페이지 테이블 엔트리마다 __`Valid-Invalid Bit`__ 가 딸려있다. 

  * _1 : 메모리 내에 있음_
  * _0 : 메모리 내에 없음_

* 예시

  <center><img src="./img/Valid-Invalid Bit.png" style="width: 30vw;"></img></center>

* 주소 변환중, 페이지 테이블 엔트리의 __유무효비트__ 가 0이라면 __`page fault`__ 를 발생시킨다.



<center><img src="./img/Page Table in Demand Paging.png" style="width: 60vw;"></img></center>

* 주 메모리에 페이지 일부가 올라오지 않은 페이지 테이블의 경우
  * 페이지가 메모리로 올라오면 유무효비트가 설정된다 - 1
* 페이지가 디스크 내에 있으면
  * 유무효비트는 설정되지 않은 상태(또는 무효상태)이다 - 0
  * 프레임의 값에 그 페이지가 저장되어있는 디스크 주소를 기록해둔다.

* 페이지 부재
  * 프로세스가 메모리에 존재하지 않는 페이지에 접근하려 시도 했을 때 `Page fault ` 트랩이 일어난다.
  * 즉, 처음에 메모리에 없는 숫자를 가져올때 (메모리 내부에 아무것도 없을때)도 페이지 부재가 일어난다.



<center><img src="./img/Steps in Handling a Page Fault.png" style="width: 60vw;"></img></center>

* 페이지 부재 처리 방식
  * 페이지 테이블 내의 유무효비트로 메모리 내에 페이지가 존재하는지 확인한다.
    * 존재하지 않는다면,
      * OS에 페이지 부재 트랩을 발동시킨다.
      * 디스크에서 페이지를 찾는다.
      * 가용한 프레임을 찾는다.
      * 디스크에서 새로 할당된 프레임(가용한 프레임)으로 페이지를 읽어온다.
      * 페이지 테이블을 갱신한다.
      * 명령을 재실행한다.
  * 물리주소로 변환해서, 데이터를 얻기위해 물리메모리에 접근한다.
* 페이지 부재 처리를 하는동안 프로세스는 waiting상태가 된다. 물론 연산이 많아지지만, 굉장히 빨리 해서 우리가 못알아 챌 정도이고, 결과적으로 가상메모리로 인해 한번에 램 용량 이상의 여러 프로세스들을 돌릴 수 있으므로 사용하는 것이다.



* 만약에 가용한 프레임이 없다면 어떻게 되는가?
  * `Page Fault` 는 새 페이지를 읽어올 타겟 프레임을 찾아야한다
  * 그런데 만약 __free frame이 없다면?__ 
    * 유효한 프레임 중 하나가 새로운 프레임으로 교체되어야 할 것이다.
  * __Page replacement__ - 메모리에서 사용하고있지 않은 프레임을 찾아서 스왑 아웃하고, 새 페이지를 스왑인 하는것
    * 페이지 교체에 사용되는 여러 알고리즘이 있다.
    * 성능 : 주어진 문자열에 대해 _가 최소 페이지부재만을 일으키는_  알고리즘을 찾아야 한다.



#### Performant of Demand Paging

* __Page Fault Rate__ 0 ≤ p ≤ 1.0
  * p = 0 이면 페이지 부재가 일어나지 않은 것
  * p = 1 이면 모든 참조가 페이지 부재를 일으키는 것
* __Effective Access Time (EAT)__
  * EAT = (1-p) * [메모리 접근 시간] + p x [페이지 부재율]
  * EAT가 작을수록 성능이 더 좋은 것이다.
* `Page fault time` 은 다음을 포함한다.
  * 페이지 부재 오버헤드
  * 페이지 스왑아웃 시간
  * 페이지 스왑인 시간
  * 재시작 오버헤드
* 예시
  * 메모리 접근시간이 200 나노초이고, 페이지 부재시간이 8 밀리초라고 하자.
  * EAT = (1-p) * (200나노초) + p * (8밀리초)
    * = (1-p) * (200) + p * (8,000,000)
    * = 200 + 7,999,800 * p (나노초)
  * EAT는 __페이지 부재율 p__ 에 __정비례__ 한다.



---

### Page Replacement

* _다중 프로그래밍 정도_ 를 더 올리면, _메모리 과할당(over-allocating)_ 이 발생한다.
  * 각 프로세스의 페이지 수 총합 > 물리메모리의 총 프레임 수
* 요구 페이징 기법에서는, _사용되는(active) 페이지_ 만이 물리메모리에 존재한다.
  * 페이지는 사용되기 전까지는 적재되지 않는다.
* 만약 _새 페이지가 적재되었고, 가용한 프레임이 없다면_ 
  * 메모리 내의 페이지들 중 하나가 새로운 페이지와 교체되어야한다. -> `Page Replacement`
* `Page Replacement` 는 논리메모리와 물리메모리 사이의 분리를 완성시킨다.
  * 작은 물리메모리에서 큰 가상메모리를 제공한다.



#### Basic Page Replacement

1. __디스크에서 필요한 페이지 위치를 알아낸다.__
2. __가용한 프레임을 찾는다.__
   1. 가용한 프레임이 있다면,  그것을 사용한다.
   2. 가용한 프레임이 없다면, `victim frame` 을 고르기 위해 __페이지 교체 알고리즘__ 을 이용한다.
3. 새롭게 비워진 프레임에 __필요한 페이지를 읽어오고, 프레임 테이블을 수정한다__ 
4. 프로세스를 __재시작__ 한다.



<center><img src="./img/Page Replacement procedure.png" style="width: 60vw;"></img></center>

#### Page Replacement Algorithm

* 다양한 교체 알고리즘이 있다.
  * FIFO 선입선출
  * Optimal 최적화
  * LRU
  * LRU-approximation (LRU 근사)
    * 부가적 참조 비트 알고리즘
    * 2차 기회 알고리즘
  * Counting-based 계수 기반
* 페이지 교체 알고리즘의 성능은 페이지 부재율로 평가된다.
  * 페이지 부재율이 낮을수록, 성능이 더 좋은 것이다.

<center><img src="./img/Page Faults vs Number of Frames.png" style="width: 60vw;"></img></center>

* 일반적으로, 프레임 갯수가 늘어날수록(물리 메모리를 추가할수록) 페이지 부재 수는 어떤 최소값으로 떨어진다.



#### First-In-First-Out (FIFO) Algorithm

![스크린샷 2020-06-14 오전 2.54.24](/Users/seongik/Library/Application Support/typora-user-images/스크린샷 2020-06-14 오전 2.54.24.png)

- 가장 오래된 페이지를 교체한다.
- 참고 스트링 : 1,2,3,4,1,2,5, 1,2,3
- 3개의 프레임 -> 페이지 부재 9번, 4프레임 -> 페이지 부재 10번

![스크린샷 2020-06-14 오전 2.56.50](/Users/seongik/Library/Application Support/typora-user-images/스크린샷 2020-06-14 오전 2.56.50.png)

- 페이지 교체 - Belady’s Anomaly 벨라디의 모순

- - 프레임을 더 주었는데도 페이지 부재 횟수가 증가할 수 있다.









