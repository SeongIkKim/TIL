

Chapter 9 - Virtual Memory Management
--------------

### Background

#### Virtual Memory

* 유저의 논리메모리를 물리 메모리로부터 분리하는 개념이다.
  * 실행을 위해서 __프로그램의 일부분만__ 메모리에 올라오도록 한다.
  * 물리 주소 공간보다 __훨씬 더 큰__ 논리 주소공간을 가질 수 있도록 해주는 개념이다.
  * 주소공간들은 여러 프로세스들간에 _공유될 수 있다_ .
  * _더 효과적인 프로세스 생성_ 을 돕는다.
* 가상 메모리는 다음을 통해 구현된다.
  * __`Demand Paging`__
  * __`Demand segmentation`__

<center><img src="./img/Virtual Memory.png" style="width: 60vw;"></img></center>

* 논리 메모리와 물리 메모리의 분리는 프로그래머가 __매우 큰__ 가상 메모리를 가질 수 있게 해준다.
* 프로그래머는 더이상 가용한 물리메모리의 양을 신경 쓸 필요가 없다.
* `MMU` 는 가상주소를 물리주소로 매핑해준다.
* 위 그림에서, 오른쪽 원통의 박스 하나하나하나가 하나의 페이지이다.
* 8기가의 램밖에 없는데 100기가의 메모리를 요구하는 프로세스가 있다면, 다른 프로세스로부터 페이지를 뺏어서 마치 100기가가 있는 것 처럼 가상 메모리를 만들면 된다.



#### Virtual-address Space

<center><img src="./img/Virtual address space.png" style="width: 30vw;"></img></center>

* 가상 주소공간은
  * _프로세스가 메모리에 저장되는 논리적인 모습이다._
  * 일반적으로 특정 논리 주소(보통 0번지)에서 시작한다.
* 프로세스는 _연속적(contiguous) 메모리_ 로 이루어진다.
* 프로세스는 _네 부분_ 으로 이루어진다.
  * 코드, 데이터, 힙, 스택
* 힙은 주소공간 위쪽으로 확장된다.
* 스택은 주소공간 아래쪽으로 확장된다.
* 힙과 스택 사이의 커다란 빈 공간도 가상 주소 공간의 일부이나, 힙이나 스택이 확장해야만 실제 물리 페이지를 요구하게 된다.



---

### Demand Paging

* 가상 메모리 관리 전략이다.
* __페이지는 프로그램 실행 도중 그것들이 필요할 때에만 메모리로 올라온다__ -> `dynamic loading`
  * 입출력 요구 감소
  * 필요 메모리 감소
  * 더 빠른 반응속도
  * 더 많은 사용자 수용 가능
* 페이지가 필요하다면, 참조한다
  * 유효하지 않은 참조라면 참조를 중단한다.
  * 메모리에 존재하지 않는다면 메모리로 가져온다.



#### Demand-paging system with swapping

* _요구 페이징 시스템_ 은 프로세스가 보조 메모리(통상 디스크)에 존재한다는 점에서 _스와핑을 이용한 페이징 시스템_ 과 비슷하다.
* 요구 페이징에서 프로세스는 하나의 연속된 주소공간보다는, _페이지들의 연속_ 이라고 할 수 있다.
* 프로세스가 __생성__ 된다면, __Lazy Swaaper(pager)__ 가 사용된다.
  * 페이지가 필요할 때까지 페이지를 스왑 인 해오지 않는다.
  * __pure demand paging__ : 어떤 페이지도 가져오지 않은 상태에서 프로세스를 실행하는 것. 항상 페이지 부재 트랩이 발생한다.



#### Valid-Invalid Bit

* 요구 페이징 시스템에서, 일부 페이지들은 메모리에 있고 나머지 페이지들은 디스크에 존재한다. 따라서 이 두가지 경우를 구별할 하드웨어적인 서포트가 필요하다.

* 각 페이지 테이블 엔트리마다 __`Valid-Invalid Bit`__ 가 딸려있다. 

  * _1 : 메모리 내에 있음_
  * _0 : 메모리 내에 없음_

* 예시

  <center><img src="./img/Valid-Invalid Bit.png" style="width: 30vw;"></img></center>

* 주소 변환중, 페이지 테이블 엔트리의 __유무효비트__ 가 0이라면 __`page fault`__ 를 발생시킨다.



<center><img src="./img/Page Table in Demand Paging.png" style="width: 60vw;"></img></center>

* 주 메모리에 페이지 일부가 올라오지 않은 페이지 테이블의 경우
  * 페이지가 메모리로 올라오면 유무효비트가 설정된다 - 1
* 페이지가 디스크 내에 있으면
  * 유무효비트는 설정되지 않은 상태(또는 무효상태)이다 - 0
  * 프레임의 값에 그 페이지가 저장되어있는 디스크 주소를 기록해둔다.

* 페이지 부재
  * 프로세스가 메모리에 존재하지 않는 페이지에 접근하려 시도 했을 때 `Page fault ` 트랩이 일어난다.
  * 즉, 처음에 메모리에 없는 숫자를 가져올때 (메모리 내부에 아무것도 없을때)도 페이지 부재가 일어난다.



<center><img src="./img/Steps in Handling a Page Fault.png" style="width: 60vw;"></img></center>

* 페이지 부재 처리 방식
  * 페이지 테이블 내의 유무효비트로 메모리 내에 페이지가 존재하는지 확인한다.
    * 존재하지 않는다면,
      * OS에 페이지 부재 트랩을 발동시킨다.
      * 디스크에서 페이지를 찾는다.
      * 가용한 프레임을 찾는다.
      * 디스크에서 새로 할당된 프레임(가용한 프레임)으로 페이지를 읽어온다.
      * 페이지 테이블을 갱신한다.
      * 명령을 재실행한다.
  * 물리주소로 변환해서, 데이터를 얻기위해 물리메모리에 접근한다.
* 페이지 부재 처리를 하는동안 프로세스는 waiting상태가 된다. 물론 연산이 많아지지만, 굉장히 빨리 해서 우리가 못알아 챌 정도이고, 결과적으로 가상메모리로 인해 한번에 램 용량 이상의 여러 프로세스들을 돌릴 수 있으므로 사용하는 것이다.



* 만약에 가용한 프레임이 없다면 어떻게 되는가?
  * `Page Fault` 는 새 페이지를 읽어올 타겟 프레임을 찾아야한다
  * 그런데 만약 __free frame이 없다면?__ 
    * 유효한 프레임 중 하나가 새로운 프레임으로 교체되어야 할 것이다.
  * __Page replacement__ - 메모리에서 사용하고있지 않은 프레임을 찾아서 스왑 아웃하고, 새 페이지를 스왑인 하는것
    * 페이지 교체에 사용되는 여러 알고리즘이 있다.
    * 성능 : 주어진 문자열에 대해 _최소 페이지부재만을 일으키는_  알고리즘을 찾아야 한다.



#### Performant of Demand Paging

* __Page Fault Rate__ 0 ≤ p ≤ 1.0
  * p = 0 이면 페이지 부재가 일어나지 않은 것
  * p = 1 이면 모든 참조가 페이지 부재를 일으키는 것
* __Effective Access Time (EAT)__
  * EAT = (1-p) * [메모리 접근 시간] + p x [페이지 부재율]
  * EAT가 작을수록 성능이 더 좋은 것이다.
* `Page fault time` 은 다음을 포함한다.
  * 페이지 부재 오버헤드
  * 페이지 스왑아웃 시간
  * 페이지 스왑인 시간
  * 재시작 오버헤드
* 예시
  * 메모리 접근시간이 200 나노초이고, 페이지 부재시간이 8 밀리초라고 하자.
  * EAT = (1-p) * (200나노초) + p * (8밀리초)
    * = (1-p) * (200) + p * (8,000,000)
    * = 200 + 7,999,800 * p (나노초)
  * EAT는 __페이지 부재율 p__ 에 __정비례__ 한다.



---

### Page Replacement

* _다중 프로그래밍 정도_ 를 더 올리면, _메모리 과할당(over-allocating)_ 이 발생한다.
  * 각 프로세스의 페이지 수 총합 > 물리메모리의 총 프레임 수
* 요구 페이징 기법에서는, _사용되는(active) 페이지_ 만이 물리메모리에 존재한다.
  * 페이지는 사용되기 전까지는 적재되지 않는다.
* 만약 _새 페이지가 적재되었고, 가용한 프레임이 없다면_ 
  * 메모리 내의 페이지들 중 하나가 새로운 페이지와 교체되어야한다. -> `Page Replacement`
* `Page Replacement` 는 논리메모리와 물리메모리 사이의 분리를 완성시킨다.
  * 작은 물리메모리에서 큰 가상메모리를 제공한다.



#### Basic Page Replacement

1. __디스크에서 필요한 페이지 위치를 알아낸다.__
2. __가용한 프레임을 찾는다.__
   1. 가용한 프레임이 있다면,  그것을 사용한다.
   2. 가용한 프레임이 없다면, `victim frame` 을 고르기 위해 __페이지 교체 알고리즘__ 을 이용한다.
3. 새롭게 비워진 프레임에 __필요한 페이지를 읽어오고, 프레임 테이블을 수정한다__ 
4. 프로세스를 __재시작__ 한다.



<center><img src="./img/Page Replacement procedure.png" style="width: 60vw;"></img></center>

#### Page Replacement Algorithm

* 다양한 교체 알고리즘이 있다.
  * FIFO 선입선출
  * Optimal 최적화
  * LRU
  * LRU-approximation (LRU 근사)
    * 부가적 참조 비트 알고리즘
    * 2차 기회 알고리즘
  * Counting-based 계수 기반
* 페이지 교체 알고리즘의 성능은 페이지 부재율로 평가된다.
  * 페이지 부재율이 낮을수록, 성능이 더 좋은 것이다.

<center><img src="./img/Page Faults vs Number of Frames.png" style="width: 60vw;"></img></center>

* 일반적으로, 프레임 갯수가 늘어날수록(물리 메모리를 추가할수록) 페이지 부재 수는 어떤 최소값으로 떨어진다.



#### First-In-First-Out (FIFO) Algorithm

<center><img src="./img/FIFO Algorithm.png" style="width: 60vw;"></img></center>

- 가장 오래된 페이지를 교체한다.
- 참고 스트링 : 1,2,3,4,1,2,5, 1,2,3
- 3개의 프레임 -> 페이지 부재 9번, 4프레임 -> 페이지 부재 10번

<center><img src="./img/Belady's Anomaly.png" style="width: 60vw;"></img></center>

- 페이지 교체 - Belady’s Anomaly 벨라디의 모순

  - 4프레임의 페이지 부재 갯수가 3프레임의 페이지 부재 갯수보다 더 크다.

- - 프레임을 더 주었는데도 페이지 부재 횟수가 증가할 수 있다.
  - 이는 특수한 상황이고, 일반적으로는 프레임이 클 수록 페이지 부재 갯수가 줄어든다.

<center><img src="./img/FIFO Page Replacement.png" style="width: 60vw;"></img></center>



#### Optimal Algorithm

* _앞으로 오랫동안 사용되지 않을 페이지_ 를 교체하는 것

* 나중에 들어올 참조 스트링을 미리 알아야하기 때문에(즉, 미래를 알아야 하기 때문에) __구현하기가 어렵다__ - 일반적으로 불가능하다.

* 알고리즘 성능을 평가하기위한 척도로 사용된다.

  * ex) 새로운 알고리즘이 최악의 경우에도 최적 알고리즘보다 12.3% 이상 나빠지지 않으며, 평균적으로 4.7% 차이밖에 나지 않는다

  <center><img src="./img/Optimal Page Replacement.png" style="width: 60vw;"></img></center>



#### Least Recently Used (LRU) Algorithm

* 사용된 지 가장 오래된 페이지를 교체한다.
* 구현
  * 카운터(계수기)로 구현
    * _모든 페이지_ 는 카운터를 가지고 있다. _페이지가 참조될 때마다 카운터에 현재시간(즉, 참조시간)을 기록_ 한다.
    * 페이지를 교체할 때, 카운터가 가장 오래된 것(시간값이 가장 작은 것)을 찾아서 교체한다.
  * 스택으로 구현
    * 스택의 중간에서 페이지를 제거하기 위해 __이중 연결 리스트__ 형태로 _페이지넘버 스택_ 을 저장해둔다
    * 페이지가 참조될 때,
      * 스택의 중간에서 페이지를 제거하고 top에 집어넣는다. 이렇게 함으로써, top에는 가장 최신에 참조된 페이지가 위치하고, bottm에는 가장 오랫동안 참조되지 않은 페이지가 위치한다.
      * 교체할 때는 스택의 bottom에서 오래된 페이지를 찾아 교체하면 된다.
      * 교체를 위해 페이지를 탐색할 필요가 없다.

<center><img src="./img/LRU Page Replacement.png" style="width: 60vw;"></img></center>



#### Counting Algorithm

* 각 페이지에 _참조 횟수 카운터_ 를 기록한다.
* `LFU Algorithm` : 가장 __작은__ 카운트의 페이지를 교체한다.
* `MFU Algorithm` : 가장 __큰__ 카운트의 페이지를 교체한다.
  * 가장 작은 참조 회수를 가진 페이지가 가장 최근에 메모리로 적재되었고, 앞으로 계속 사용될 것이라는 판단에 근거한 것이다.



---

### Allocation of Frames

- __다양한 프로세스간__ 에 _제한된 가용메모리_ 를 할당하려면 어떻게 해야하는가?

- - 두개의 프로세스에 93개의 free frame을 할당하려면, 각 프로세스에 얼마나 할당해야하지?

- 제약조건

- - 가용한 프레임 전체보다 많이 할당할 수는 없다
  - 각 프로세스는 필요한 __최소 페이지수__ 가 있다

- 자주 사용되는 할당 알고리즘

- - ` Equal allocation 균등 할당`

  - - 프로세스 개수로 1/n 하여 프레임을 할당한다.

  - ` Proportional allocation 비례 할당`

    - __프로세스 크기__ 에 비례해서 더 많은 프레임을 주는것
    - 그러나 이 두 방식은 프로세스의 우선순위를 전혀 고려하지 않고있다. 따라서, `비례할당` 방식을 사용할 때 __크기__ 가 아니라 __우선순위__ 를 고려할 필요가 있다.



---

### Thrashing

- 프로세스가 _충분한 프레임을 가지고 있지 않을때_  , 페이지 부재율이 매우 높아진다. 이는 다음을 야기한다.

- - __낮은 CPU 이용률__ : CPU 이용시간보다 페이징 시간이 더 많아지게 된다.
  - OS는 CPU의 이용률을 감시하고 있다. CPU 이용률이 너무 낮으므로 OS는 CPU가 한가하다고 생각하고 다중 프로그래밍정도를 늘려야겠다고 생각하게 한다. 그러나 실제로는 과도한 페이징때문에 CPU를 사용하지 못하고 있는것이다.
  - 시스템에 또 다른 프로세스가 추가된다. 이는 다시 더 많은 페이지 부재와 더 긴 페이징 장치 대기 시간을 낳는다.

- `Thrashing` : 프로세스가 페이지를 스와핑하느라 바쁜것

- - 과도한 페이징 작업 (High paging activity)
  - __수행시간보다 페이징 시간이 더 길면__ 프로세스가 쓰래싱하고있다고 말한다.

<center><img src="./img/Thrashing.png" style="width: 60vw;"></img></center>

* CPU 이용률 vs 다중프로그래밍 정도(DM)
  * DM이 더 늘면, CPU 이용률도 최대에 도달할 때까지 늘어난다.
  * DM이 더 늘면, 쓰래싱이 일어나고, CPU 이용률은 급격히 떨어진다.
  * DM을 줄이는 것이 쓰래싱의 해결책이 될 수 있다.