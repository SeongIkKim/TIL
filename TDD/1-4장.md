본 글은 켄트 백의 <테스트 주도 개발>을 읽고 개인적으로 정리한 내용입니다. 내용에 오류가 있을 시 지적해주시면 감사하겠습니다.

# 저자의 글



### 테스트 주도 개발의 2원칙

* 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다.

* 중복을 제거한다.



이 규칙에 의거하여 행동 패턴이 만들어지고, 다음과 같은 프로그래밍 순서가 만들어진다.

* `빨강`  - 실패하는 작은 테스트를 작성한다. 컴파일이 되지 않아도 좋다.
* `초록` - 빨리 테스트가 통과하게끔 만든다. 이 과정에서 코드 복붙, 테스트 통과를 위해 함수가 무조건 상수를 반환하기 등의 꼼수를 써도 상관없다.
* `리팩토링` - 일단 테스트를 통과하게만 하는 와중에 생겨난 모든 중복을 제거한다.



----



# 1장 - 다중 통화를 지원하는 Money 객체



* 다중통화를 지원하는 보고서를 생성하려면, 기존의 금액체계에 통화 단위를 추가하고, 환율을 명시해야 한다.

  > 예를들어, $5 + 10CHF = $10(환율이 2:1일 경우)
  >
  > 따라서 $5 * 2 =$10

* 이 과정에서 해야할 일은 두 가지가 나온다.

  * 통화가 다른 두 금액을 더해 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 함
  * 주가 * 주식 수의 금액을 결과로 얻을 수 있어야 함



보아하니 첫번째 테스트는 좀 복잡해보인다. 가벼운 일부터 먼저 처리하자. 두번째 테스트부터 작성한다.



```java
public void testMultiplication() {
  Dollar five = new Dollar(5);
  five.times(2);
  assertEquals(10, five.amount);
}
```

이 코드는 지금 '빨강' 상태이다. public 필드이기도 하고, 금액 계산에 정수형을 사용하고 있다. 일단 '초록'을 보기 위해 문제사항들을 다 적어놓고 진행한다.

* $5 + 10CHF = $10(환율이 2:1일 경우)
* $5 * 2 = $10
* amount를 private으로 만들기
* Dollar 부작용?
* Money 반올림?



컴파일이 되게 만드려면 다음과 같은 컴파일에러를 해결해야한다.

> 1. Dollar 클래스가 없음
>
> 2. 생성자가 없음
>
> 3. times(int) 메서드가 없음
>
> 4. amount 필드가 없음



일단 컴파일이 되게 하기 위해서, 위의 구현들을 정말 '최소한'으로 한다.(정말 아무 로직도 안짜도 된다)



```java
class Dollar // #1
```

```java
Dollar(int amount) // #2
```

```java
void times(int multiplier) // #3
```

```java
int amount; // #4
```



컴파일은 되었지만, amount의 예상액이 10이 나와야 assertEquals를 통과하는데, amount값이 0이라 통과하지 못한다. 따라서



```java
int amount=10;
```



amount를 그냥 10으로 바꿔준다.(...??)

어찌됐든 결과가 앞으로 이렇게 나와야 하니, __껍데기만 작성__ 해두자. 그럼 테스트를 통과했다!



그렇다면 이제 중복을 제거한다. 위의 예제에서는 중복이 잘 보이지 않는것 같지만, 사실은 다음과 같은 중복이 있음을 알 수 있다.

```java
int amount = 5 * 2; // new Dollar(5)와 five.times(2)에서 나왔던 5와 2가 중복하여 등장하고 있다.
```

따라서 다음과 같이 리팩토링하여 중복을 제거한다.

```java
int amount;

Dollar(int amount){
  this.amount = amount;
}

void times(int multiplier){
  // amount = 5 * 2;
  // amount = amount * 2;
  // amount = amount * multiplier;
  // amount *= multiplier;
}
```



그럼 우리는 적어도 다섯가지 문제사항 중 두번째는 해결한 것이다.

* $5 + 10CHF = $10(환율이 2:1일 경우)
* ~~$5 * 2 = $10~~
* amount를 private으로 만들기
* Dollar 부작용?
* Money 반올림?



---

# 2장 타락한 객체



우리의 목적은 __작동하는 깔끔한 코드__ 를 얻는것이다.

이를 위해서 먼저 **'작동하는'** 부분에 집중하고, 그 다음에 **'깔끔한'** 부분을 해결한다.



* $5 + 10CHF = $10(환율이 2:1일 경우)
* ~~$5 * 2 = $10~~
* amount를 private으로 만들기
* **Dollar 부작용?**
* Money 반올림?

다섯가지 문제 사항 중 4번에 집중해보자.

```java
public void testMultiplication(){
  Dollar five = new Dollar(5);
  five.times(2);
  assertEquals(10, product.amount);
  five.times(3);
  assertEquals(15, product.amount);
}
```



달러를 multiple하는 테스트를 작성했다고 쳤을 때, `five.times(2)` 를 거치면 Dollar five의 amount는 10으로 바뀐다. 이 상태로 assertEquals를 한번 실행하고, 다음번에 다시 `five.times(3)` 을 거치면 당연히 `five.amount` 는 10*3 = 30이 될 것이다. 테스트를 통과하지 못하는 것이다.

따라서 테스트용으로 사용할 five라는 Dollar 객체의 값은 5로 고정되어있어야한다. 그러므로 five를 오염시키지 않기 위해서, 우리는 `times()` 함수가 새로운 객체를 반환하여야 한다는 것을 유추해낼 수 있다.

따라서 테스트를 다음과 같이 수정한다.



```java
public void testMultiplication(){
  Dollar five = new Dollar(5);
  Dollar product = five.times(2);
  assertEquals(10, product.amount);
  product = five.times(3);
  assertEquals(15, product.amount);
}
```



이렇게 테스트 코드를 수정했다면, `Dollar.times()` 를 수정하지 않으면 새 테스트는 당연히 수정조차 되지 않을 것이다.



```java
Dollar times(int multiplier) {
  amount *= multiplier;
  return null; // 테스트가 돌아가도록 하기 위한 정말 최소한의 컴파일만 수행(초록 막대)
}
```



return 값을 올바르게 고치면, 다음과 같다.



```java
Dollar times(int multiplier){
  return new Dollar(amount * multiplier);
}
```



[테스트 코드의 껍데기를 짜고(빨강)] -> [컴파일만 되도록 고치고(초록)] -> [중복을 제거하며 올바른 값을 내뱉도록 바꾸고(리팩토링)]의 과정이 너무 잘게 쪼개어져 있어서 넘어가기 쉽지만, __이 과정들을 쪼개어 (최소한 머릿속으로) 순차적으로 처리할 수 있는 능력이 저자가 요구하는 TDD__ 라는 생각이 든다.

초록을 보기 위해 취할 수 있는 전략 세 가지 중 두 가지는 다음과 같다.

* 가짜로 구현하기 : 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 나간다.
* 명백한 구현 사용하기 : 실제 구현을 입력한다.

뭘 입력해야할 지 명확히 알고, 테스트코드도 정확하게 짜고 있다면 후자를 지속한다. 그러다 예상치 못한 '빨강'을 만나면 전자를 사용하여 올바른 코드로 리팩토링한다. 이 두 가지 방법을 때에 맞추어 스왑해가며 사용하자.

