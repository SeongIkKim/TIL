본 글은 켄트 백의 <테스트 주도 개발>을 읽고 개인적으로 정리한 내용입니다. 내용에 오류가 있을 시 지적해주시면 감사하겠습니다.



# 18장 xUnit으로 가는 첫 걸음

#

2부는 그나마 익숙한 파이썬으로 들어왔기 때문에, 의식의 흐름대로 따라가는것이 아니라 한 장마다 테스트코드를 정리하고, 코멘트를 달아볼 것이다.

#

2부의 주제는 jUnit을 본딴 xUnit, 즉 테스트툴을 직접 만들어보는 것이다. 그것도 TDD로. 이에 따른 할 일 목록을 정리해본다.

#

> **○ 테스트 메서드 호출하기**
>
> ○ 먼저 setUp 호출하기
>
> ○ 나중에 tearDown 호출하기
>
> ○ 테스트 메서드가 실패하더라도 tearDown 호출하기
>
> ○ 여러 개의 테스트 실행하기
>
> ○ 수집된 결과를 출력하기

#

이 todo-list를 매번 정리하면서 느끼는 점은, 저자 머릿속에는 저 목록들이 뭘 의미하는지 정리되어 있지만, 독자들은 저걸 한눈에 파악하기 힘들다는 것이다. 나만 그런건지는 모르겠는데, 적어놓은 todo-list들은 한 개씩 각 장에서 '격파(!)'한다는 느낌으로 그 때 그 때 이해할 수 밖에 없다.



고로 스트레스 받지 말고 그냥 그런가보다 하고 의식의 흐름을 따라 코딩해보자. 지나고 보면 다 맞는말이긴 하다. ~~개똥같이 말하긴 하지만.(...)~~

#

테스트케이스를 실행할 때, 그에 알맞은 테스트메서드가 제대로 호출되었는지를 확인하는 것은 중요하다. 호출을 기록해두는 클래스로 WasRun을 만들기로 한다. 또, 호출부를 하드코딩하는것이 아니라 메서드 추출하여 반복사용할 수 있는 TestCaseTest 클래스를 만들어준다.

#

```python
class TestCase:
    def __init__(self, name):
        self.name = name

    def run(self):
        '''
        메서드 동적 호출
        getattr(object, name, default)는 object 내에서 주어진 string(name)과 동일한 method를 반환해준다.
        따라서 테스트케이스의 이름을 전달했을 때, 해당 테스트케이스가 호출되었는지를 기록할 수 있다.
        '''
        method = getattr(self, self.name) # 상수를 변수(method)로 변화시켜 일반화하는 리팩토링의 예
        method()


class WasRun(TestCase):
    def __init__(self, name):
        self.wasRun = None # 테스트케이스가 호출되었는지를 알려주는 어트리뷰트
        TestCase.__init__(self, name)

    def testMethod(self):
        '''
        메서드 호출여부 기록
        메서드가 호출되었는지를 기억(flag)하는 메서드
        '''
        self.wasRun = 1


class TestCaseTest(TestCase):
    def testRunning(self):
        '''
        test 코드 실행 메서드
        실행 과정을 print문이 아니라 assertion 형태로 구현
        '''
        test = WasRun("testMethod")
        assert(not test.wasRun) # not None이므로, True 반환
        test.run() # testMethod()를 직접 호출하지 않고, run()이라는 함수를 두어 두 부분을 분리함
        assert(test.wasRun) # 1

# main

TestCaseTest("testRunning").run() # 성공!
```

#

모든 테스트코드에서 자주 사용되는 `assert()`  는 가정설정문으로, 추정한 형태의 값이나 True가 나오지 않으면 Assertion Error를 발생시킨다(in python). 코딩을 하는 과정에서 결과값을 예측하여 오류를 방어해둔다는 입장에서 '방어적 프로그래밍'의 일환으로 보기도 한다.

#

위의 코드에서 사용된 `getattr()` 내장함수는 Pluggable Selector라고 할 수 있는데, 위치에 맞게 뺐다 끼웠다 할 수 있는 플러그처럼 런타임에서 특정 메서드, 속성등을 찾아 selecting해주는 역할을 한다.



위의 예시에서는 method의 이름을 각각 if-else나 switch로 하드코딩 하지 않아도 되어 훨씬 효율적이라고 생각할 수 있지만, 정적 코드 분석을 어렵게 하는 주범이니 함부로 남발하진 말자.

#

[정적 코드 분석](https://ko.wikipedia.org/wiki/%EC%A0%95%EC%A0%81_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8_%EB%B6%84%EC%84%9D) 은 실제 실행없이 코드를 분석하는 일이다.

동적 코드 분석은 Run타임에서 결과값을 즉시 확인하고 에러를 고칠 수 있지만, 코드의 흐름을 따라가기 어렵고 결과값이 숨겨진 문제를 모두 보여주지 못한다. 예를 들어 Memory Leak는 축적되어 메모리 에러가 뜨기 전까지는 누수를 알아챌 수 없다.

따라서 논리적으로 코드의 흐름을 따라가며 문제상황을 미리 예상하거나 분석할 수 있도록 코드를 정리하여 정적코드분석을 가능하게 할 필요가 있다.



# 19장 테이블 차리기

#

> ~~○ 테스트 메서드 호출하기~~
>
> **○ 먼저 setUp 호출하기**
>
> ○ 나중에 tearDown 호출하기
>
> ○ 테스트 메서드가 실패하더라도 tearDown 호출하기
>
> ○ 여러 개의 테스트 실행하기
>
> ○ 수집된 결과를 출력하기

#

테스트코드의 공통 패턴 3A는 다음과 같다.

1. 준비(arrange) - 객체를 생성한다.
2. 행동(act) - 어떤 자극을 준다.
3. 확인(assert) - 결과를 검사한다.

#

이 중 첫 번째 단계인 준비는 여러 테스트코드에 걸쳐 동일한 경우가 많다. 이 때 각 테스트코드마다 객체를 생성하는 코드를 흩뿌려 놓을 필요는 없으므로, 이를 세팅해주는 setUp을 작성해야 한다.

이 setUp 과정에서 중요한 제약은 두가지이다.

* `성능` : 테스트코드의 실행성능은 빠를 수록 좋으므로, 같은 객체를 사용하는 여러 다른 테스트코드가 있는 경우 **객체를 하나만 생성**한다.
* `격리` : **각 테스트코드의 수행이 서로에게 영향을 미치지 않아야 한다.** 따라서, 한 테스트코드가 공유객체의 성질을 변경하여 다른 테스트의 결과에 영향을 주면 안된다.

#

일단, `성능` 은 아직 고려하지 않아도 괜찮다고 가정하고, `격리` 에 집중해보자. 테스트가 돌때마다 객체를 새로 생성하여 **"테스트 커플링"**을 피해야한다.

#

```python
class TestCase():

    def __init__(self, name):
        self.name = name

    def setUp(self):
        '''
        하위 클래스(WasRun,TestCaseTest)에서 오버라이드할 추상 메서드
        '''
        pass

    def run(self):
        '''
        메서드 동적 호출
        getattr(object, name, default)는 object 내에서 주어진 string(name)과 동일한 method를 반환해준다.
        따라서 테스트케이스의 이름을 전달했을 때, 해당 테스트케이스가 호출되었는지를 기록할 수 있다.
        '''
        self.setUp()
        method = getattr(self, self.name) # 상수를 변수(method)로 변화시켜 일반화하는 리팩토링의 예
        method()


class WasRun(TestCase):
    '''
    메서드가 실행되었는지를 알려주는 테스트클래스
    '''

    def __init__(self, name):
        self.wasRun = None # 테스트케이스가 호출되었는지를 알려주는 어트리뷰트
        TestCase.__init__(self, name)

    def testMethod(self):
        '''
        메서드 호출여부 기록
        메서드가 호출되었는지를 기억(flag)하는 메서드
        '''
        self.wasRun = 1

    def setUp(self):
        '''
        setUp 여부 기록
        여러 테스트를 실행할 때, 테스트 커플링을 피하기 위해(환경을 독립시키기 위해) 사용하는 일종의 세팅 메서드
        '''
        self.wasRun = None
        self.wasSetUp = 1


class TestCaseTest(TestCase):
    '''
    테스트케이스를 수행하는 메인 클래스
    '''

    def setUp(self):
        '''
        WasRun 인스턴스 생성 파트(각 테스트메서드마다 인스턴스를 분리하기 위하여)
        '''
        self.test = WasRun("testMethod")

    def testRunning(self):
        '''
        test 코드 실행 테스트코드
        '''
        # assert(not self.test.wasRun) # test-setUp이 존재하고 잘 돌아가므로 wasRun을 검사할 필요가 없어졌다(단순화)
        self.test.run()
        assert(self.test.wasRun) # 1

    def testSetUp(self):
        '''
        setUp 메서드 호출여부 테스트코드
        '''
        self.test.run()
        assert(self.test.wasSetUp)

# main

TestCaseTest("testRunning").run()
TestCaseTest("testSetUp").run()

```

#

중요한 점은, **한번에 메서드를 하나 이상 수정하지 않으면서 테스트가 통과하게 만들 수 있는 방법**을 찾도록 노력해야한다는 것이다.

1부에서도 언급했던, 단단한 기반(초록 막대!)에 한 발을 두면서 새로운 곳으로 발을 옮기는 것과 비슷하다. 한번에 여러 곳을 고치면, 흐름을 따라가기도 어렵고, 최적의 리팩토링을 고민할 시간을 없앤다.

... 실제 코드를 짜면서 내가 그걸 할 수 있을지는 모르겠지만.