본 글은 켄트 백의 <테스트 주도 개발>을 읽고 개인적으로 정리한 내용입니다. 내용에 오류가 있을 시 지적해주시면 감사하겠습니다.



# 5장 솔직히 말하자면

> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * **5CHF * 2 = 10CHF**



Dollar 객체를 비슷하게 본딴 Franc 객체를 만들어본다. 이전의 Dollar 테스트에서 코드를 가져온다.(재사용성!)



```java
public void testFrancMultiplication() {
  Franc five = new Franc(5);
  assertEquals(new Franc(10), five.times(2));
  assertEquals(new Franc(15), five.times(3));
}
```



이제 이전에 Dollar 테스트가 겪었던 길을 그대로 따라간다(복붙!)



```java
class Franc {
  private int amount;
  
  Franc(int amount) {
    this.amount = amount;
  }
  
  Franc times(int multiplier) {
    return new Franc(amount * multiplier);
  }
  
  public boolean equals(Object object){
    Franc franc = (Franc) object;
    return amount == franc.amount;
  }
}
```



컴파일은 일단 성공! 

그러나 이전에 만들었던 Dollar 코드와 중복이 많기 때문에, 다음 장에서는 중복을 고쳐서 재 작성할 것이다.



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * Dollar/Franc 중복
> * 공용 Equals
> * 공용 times

---



# 6장 돌아온 '모두를 위한 평등'



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * Dollar/Franc 중복
> * **공용 Equals**
> * 공용 times



`Franc`이라는 새로운 객체를 만들어 테스트코드를 작성했지만, 복붙하는 과정에서 `Dollar` 객체와 중복이 너무 많이 생겨버렸다.

따라서 두 객체의 중복되는 코드를 공통 상위 클래스 `Money`의 코드로 뺀 후, `Dollar` 와 `Franc` 이 모두 이 클래스를 상속받게 할 것이다.



``` java
class Money{
  protected int amount; // 하위 클래스(Dollar, Franc)에서도 변수를 볼 수 있도록 가시성을 private -> protected로 변경
}
class Dollar extends Money {
}
```



`amount` 를 `Money` 의 필드로 뺐다면, 다음은 `equals` 코드를 빼 올릴 차례다.



``` java
// Money
public boolean equals(Object object) {
  Money money = (Money) object;
  return amount == money.amount;
}
```



위의 과정은 축약해서 한번에 적었지만, 책에서는 `Dollar` 객체 내에서 타입 캐스팅 하나, 변수명 하나를 바꿀때마다 테스트코드에 이상이 없는지 돌려가며 수행하고, `Money` 의 메서드로 완전히 리팩토링했다고 생각될 때 `Money` 로 옮긴다. 정말 차근차근 조금씩 하는 셈.



`Money` 에 일반화된 `equals` 의 코드가 있으므로, 이제 `Franc` 의 `equals` 를 제거해야한다.

그런데 이전에 만들어뒀던 동치성 테스트( `testmultiplication` )가 `Franc` 객체에 대해서는 비교하고 있지 않으므로, `Franc` 도 테스트 할 수 있도록 테스트코드를 추가한다. (모든 테스트코드는 내부 로직을 테스트하는것이 아니라 외부로 드러나는 결과-그래서 equals인거야?-에 대해서 테스트한다. 외부, 외부.)

```java
public void testEquality() {
  assertTrue(new Dollar(5).equals(new Dollar(5)));
  assertFalse(new Dollar(5).equals(new Dollar(6)));
  assertTrue(new Franc(5).equals(new Franc(5))); 
  assertFalse(new Franc(5).equals(new Franc(6)));
  /*
 	중복된 assertTrue, assertFalse 코드에 대해서는 추후에 리팩토링한다.
  */
}
```



`Franc` 의 `equals` 도 `Dollar` 와 마찬가지로 리팩토링 한 후, 상위 클래스 `Money` 의 `equals` 와 다른 점이 없음을 확인하고 제거한다.



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * Dollar/Franc 중복
> * ~~공용 Equals~~
> * 공용 times
> * Franc와 Dollar 비교하기



---



# 7장 사과와 오렌지

*서로 다른 과일인 사과와 오렌지와 같이, 서로 다른 것을 비교할 수 없음을 이르는 관용어구이다.



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * Dollar/Franc 중복
> * ~~공용 Equals~~
> * 공용 times
> * __Franc와 Dollar 비교하기__



만약에,  `Franc`과 `Dollar`를 비교한다면 어떤 결과가 일어날까?



```java
public void testEquality() {
  assertTrue(new Dollar(5).equals(new Dollar(5)));
  assertFalse(new Dollar(5).equals(new Dollar(6)));
  assertTrue(new Franc(5).equals(new Franc(5))); 
  assertFalse(new Franc(5).equals(new Franc(6)));
  assertFalse(new Franc(5).equals(new Dollar(5)));
```



당연히 java 객체상 `Franc`와 `Dollar`는 다른 객체이므로 실패한다.



이를 명시적으로 하여, 두 통화(Currency)를 비교하여 다르면 동치성 비교를 통과하지 못하도록 코드를 작성하자.



```java
public boolean equals(Object object) {
  Money money = (Money) object;
  return amount == money.amount && getClass().equals(money.getClass());
}
```



아직 통화(Currency)의 개념이 없으므로, `equals` 메소드는 두 객체(통화)의 클래스가 완전히 동일해야 한다는 조건을 추가한다. 그러나 이는 자바 코드(클래스)적인 측면이지, 재정 개념적으로 명확한 비교가 아니다. 일단 당장에 통화 개념을 만들어야 할 필요성은 없으니 일단 할일 목록에 추가해 둔다.



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * Dollar/Franc 중복
> * ~~공용 Equals~~
> * 공용 times
> * ~~Franc와 Dollar 비교하기~~
> * 통화?



이제 다음장에서는 공통의 `times()` 코드를 처리해보기로 한다. 따라서 혼합된 통화의 연산을 다룰것이다.