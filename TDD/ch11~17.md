본 글은 켄트 백의 <테스트 주도 개발>을 읽고 개인적으로 정리한 내용입니다. 내용에 오류가 있을 시 지적해주시면 감사하겠습니다.



# 11장 모든 악의 근원



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * **Dollar/Franc 중복**
> * ~~공용 Equals~~
> * ~~공용 times~~
> * ~~Franc와 Dollar 비교하기~~
> * ~~통화?~~
> * testFrancMultiplication 제거



#

이제 Dollar와 Franc은 생성자밖에 남지 않았다. 생성자까지 모두 제거하여 하위 클래스를 제거하자.

#



```java
// Money 코드
static Money franc(int amount) {
  return new Money(amount, "CHF"); // 원래는 Franc
}

static Money dollar(int amount) {
  return new Money(amount, "USD"); // 원래는 Dollar
}
```

 

#

Dollar는 이제 어느 코드에서도 사용되지 않지만, Franc에 대한 참조는 테스트코드에 아직 남아있다.

#



``` java
public void testDifferentClassEquality() {
  assertTrue(new Money(10, "CHF").equals(new Franc(10, "CHF")));
}
```



#

`testEquality()` 동치성 테스트에서 이미 충분히 테스트하고있으므로, 위의 코드를 제거하자. 추가로, testEquality 내의 중복 코드도 제거하자.

#



```java
public void testEqaulity() {
  assertTrue(Money.dollar(5).equals(Money.dollar(5)));
  assertFalse(Money.dollar(5).equals(Money.dollar(6)));
	// assertTrue(Money.franc(5).equals(Money.franc(5))); 1번째 줄과 겹치므로 삭제
  // assertFalse(Money.franc(5).equals(Money.franc(6))); 2번째 줄과 겹치므로 삭제
  assertFalse(Money.franc(5).equals(Money.dollar(5)));
}
```



#

이전 장에서 다루었던 currency 비교의 경우, 여러 클래스가 존재할 때만 의미가 있다. 애초에 클래스가 다른 것들끼리 currency 개념으로 동일하게 비교하려고 만든 것이기 때문이다. 그러나 이제는 하위 클래스를 제거하려 하므로, Franc 클래스와 Money 클래스의 currency를 비교하고 클래스가 달라도 잘 작동하는지 테스트하는 `testDifferentClassEquality()` 테스트는 필요가 없다.



마찬가지로, 달러와 프랑 각각에 대한 테스트 코드는 이제 Money에 대한 테스트 코드 하나로 통합될 수 있다. 굳이 따로 둘 필요가 없는것이다.



#



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * ~~Dollar/Franc 중복~~
> * ~~공용 Equals~~
> * ~~공용 times~~
> * ~~Franc와 Dollar 비교하기~~
> * ~~통화?~~
> * testFrancMultiplication 제거



---



# 12장 드디어, 더하기



#

각각의 화폐 단위에 대해 코드를 작성하고, 테스팅하고, 이를 리팩토링하였다면, 이제 정말 핵심적인 최초의 문제로 돌아갈 때이다.

#



> $5 + 10CHF = $10(환율이 2:1일 경우)
>
> 간단한 예 : **$5 + $5 = $10**



#

간단한 예에서 시작해보자.

#



```java
public void testSimpleAddition() {
  Money sum = Money.dollar(5).plus(Money.dollar(5));
  assertEquals(Money.dollar(10), sum);
}
```



```java
Money plus(Money addend) {
  return new Money(amount + addend.amount, currency);
}
```



#



`plus()` 라는 함수를 구현하긴 했는데, 지금까지의 객체 Money를 그냥 add하기에는 currency 개념이 걸린다. Money가 어떤 currency를 가졌느냐에 따라 환율을 계산하여 서로 다른 통화들을 더해야하는데, 현재 `plus()` 가 새로 반환하는 Money 클래스는 여러 '통화'를 다룰수는 있지만, 여러 '환율'과 '연산'을 다루지는 않는다. 따라서 두 Money 클래스의 환율을 고려한 연산결과를 표현할 `Expression` 을를 만들것이다.



Money 클래스를 그대로 사용하지 않고 굳이 새로운 Expression을 만드는 이유가 뭘까? 솔직히 책의 내용이 정확히 무엇을 이야기하려는지 명확하게 받아들이기 어렵지만, '환율 연산' 이라는 서로 다른 통화를 다루는 핵심 기능을 최대한 다른 객체로부터 분리시켜야 하기 때문인 듯하다. 다중 통화 연산을 지원하면서도 해당 코드는 다른 객체들에게 숨기고 싶은 것이다.



이에 대해  모든 currency를 하나의 참조통화(일종의 표준)으로 바꾸는 방안도 있을 수 있겠지만, 이 방식으로는 여러 환율을 계산하기가 어렵다. 대신에 편하게 환율을 표현하면서도, 산술 연산 표현을 그대로 가져갈 수 있는 수식 클래스를 새로 만드는 것이다.



이 Expression 클래스 객체는 결국에 Money 객체와 내부 구현은 다르지만, 외부적으로 드러나는 프로토콜, 형태는 같아야한다. 이를 저자는 **'imposter(사기꾼)'**이라고 말한다. Expression은 Money와 비슷하게 동작하지만, 사실은 두 Money의 합을 나타낸다.



#



```java
public void testSimplceAddition() {
  ...
  assertEquals(Money.dollar(10), reduced);
}
```



#

`reduced` 는 환율을 적용한 Expression이다.



여기서 켄트 백은 이해하기 약간 힘든 새로운 코드를 덧붙이는데, 다음과 같다.



#



```java
public void testSimplceAddition() {
  ...
  Money reduced = bank.reduce(sum, "USD");
  assertEquals(Money.dollar(10), reduced);
}
```



#



그냥 `...reduce = sum.reduce("USD", bank)` 라고 써, USD로 sum을 계산해 Expression 객체를 반환하는 코드를 만들 수도 있었을텐데, 굳이 `bank.reduce(sum, "USD")` 코드를 통해 bank가 `reduce()` 를 수행함을 명시했다.



Bank를 사용함으로써 Expression이라는 핵심 기능을 떼어내면 해당 객체는 최대한 유연해지고, 테스트하기 쉬워지고, 재활용하기 쉬워진다. OOP의 개념이 한껏 들어간 듯하다(이런 점을 보면 정말 java specific한 책이긴 하다). 학교 수업을 들어봤다면 좀 더 나았을텐데..



또, 추후 Expression 관련 오퍼레이션이 많아 질 것이 예상되므로, 모든 오퍼레이션을 Expression에 두지 않고 분산시킬 수 있게 된다.



이 시점에서 Bank를 사용하기로 한 것은 일시적인 판단으로, 추후에 이것이 필요없어지게 된다면 Expression으로 기능을 통합시킬 수도 있다. 일단 직관에 의해서 만들고, 추후에 정리해보자.



#



```java
public void testSimplceAddition() {
  Money five = Money.dollar(5);
  Expression sum = five.plus(five); // 두 Money의 합은 Expression이어야 한다.
  Bank bank = new Bank(); // Bank가 할 일은 정말 하나도 없다.
  Money reduced = bank.reduce(sum, "USD");
  assertEquals(Money.dollar(10), reduced);
}
```



#



Expression을 클래스로 만들어도 되지만, 오퍼레이션만을 담을 것이므로 더 가벼운 인터페이스로 만들기로 한다.



#



```java
interface Expresion
```

```java
Expression plus(Money addend) {
  return new Money(amount + addend.amount, currency);
}
```

```java
class Money implements Expression // Money가 Expression을 구현해야한다. 즉 Expression은 Money의 인터페이스이다.
```

```java
class Bank // 빈 클래스

Money reduce(Expression source, String to) { // reduce의 stub(dummy)
  return null;
}
```



#



컴파일이 되고, 실패한다. 빨강 막대를 보았으니 큰 진전이다. reduce를 간단히 가짜구현 해보자.



#



```java
Money reduce(Expression source, String to) {
  return Money.dollar(10);
}
```



