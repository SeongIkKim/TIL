본 글은 켄트 백의 <테스트 주도 개발>을 읽고 개인적으로 정리한 내용입니다. 내용에 오류가 있을 시 지적해주시면 감사하겠습니다.



# 11장 모든 악의 근원



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * **Dollar/Franc 중복**
> * ~~공용 Equals~~
> * ~~공용 times~~
> * ~~Franc와 Dollar 비교하기~~
> * ~~통화?~~
> * testFrancMultiplication 제거



#

이제 Dollar와 Franc은 생성자밖에 남지 않았다. 생성자까지 모두 제거하여 하위 클래스를 제거하자.

#



```java
// Money 코드
static Money franc(int amount) {
  return new Money(amount, "CHF"); // 원래는 Franc
}

static Money dollar(int amount) {
  return new Money(amount, "USD"); // 원래는 Dollar
}
```

 

#

Dollar는 이제 어느 코드에서도 사용되지 않지만, Franc에 대한 참조는 테스트코드에 아직 남아있다.

#



``` java
public void testDifferentClassEquality() {
  assertTrue(new Money(10, "CHF").equals(new Franc(10, "CHF")));
}
```



#

`testEquality()` 동치성 테스트에서 이미 충분히 테스트하고있으므로, 위의 코드를 제거하자. 추가로, testEquality 내의 중복 코드도 제거하자.

#



```java
public void testEqaulity() {
  assertTrue(Money.dollar(5).equals(Money.dollar(5)));
  assertFalse(Money.dollar(5).equals(Money.dollar(6)));
	// assertTrue(Money.franc(5).equals(Money.franc(5))); 1번째 줄과 겹치므로 삭제
  // assertFalse(Money.franc(5).equals(Money.franc(6))); 2번째 줄과 겹치므로 삭제
  assertFalse(Money.franc(5).equals(Money.dollar(5)));
}
```



#

이전 장에서 다루었던 currency 비교의 경우, 여러 클래스가 존재할 때만 의미가 있다. 애초에 클래스가 다른 것들끼리 currency 개념으로 동일하게 비교하려고 만든 것이기 때문이다. 그러나 이제는 하위 클래스를 제거하려 하므로, Franc 클래스와 Money 클래스의 currency를 비교하고 클래스가 달라도 잘 작동하는지 테스트하는 `testDifferentClassEquality()` 테스트는 필요가 없다.



마찬가지로, 달러와 프랑 각각에 대한 테스트 코드는 이제 Money에 대한 테스트 코드 하나로 통합될 수 있다. 굳이 따로 둘 필요가 없는것이다.



#



> * $5 + 10CHF = $10(환율이 2:1일 경우)
> * ~~$5 * 2 = $10~~
> * ~~amount를 private으로 만들기~~
> * ~~Dollar 부작용?~~
> * Money 반올림?
> * ~~equals()~~
> * hashCode()
> * Equal null
> * Equal object
> * ~~5CHF * 2 = 10CHF~~
> * ~~Dollar/Franc 중복~~
> * ~~공용 Equals~~
> * ~~공용 times~~
> * ~~Franc와 Dollar 비교하기~~
> * ~~통화?~~
> * testFrancMultiplication 제거



---



# 12장 드디어, 더하기



#

각각의 화폐 단위에 대해 코드를 작성하고, 테스팅하고, 이를 리팩토링하였다면, 이제 정말 핵심적인 최초의 문제로 돌아갈 때이다.

#



> $5 + 10CHF = $10(환율이 2:1일 경우)
>
> 간단한 예 : **$5 + $5 = $10**



#

간단한 예에서 시작해보자.

#



```java
public void testSimpleAddition() {
  Money sum = Money.dollar(5).plus(Money.dollar(5));
  assertEquals(Money.dollar(10), sum);
}
```



```java
Money plus(Money addend) {
  return new Money(amount + addend.amount, currency);
}
```



#



`plus()` 라는 함수를 구현하긴 했는데, 지금까지의 객체 Money를 그냥 add하기에는 currency 개념이 걸린다. Money가 어떤 currency를 가졌느냐에 따라 환율을 계산하여 서로 다른 통화들을 더해야하는데, 현재 `plus()` 가 새로 반환하는 Money 클래스는 여러 '통화'를 다룰수는 있지만, 여러 '환율'과 '연산'을 다루지는 않는다. 따라서 두 Money 클래스의 환율을 고려한 연산결과를 표현할 `Expression` 을를 만들것이다.



Money 클래스를 그대로 사용하지 않고 굳이 새로운 Expression을 만드는 이유가 뭘까? 솔직히 책의 내용이 정확히 무엇을 이야기하려는지 명확하게 받아들이기 어렵지만, '환율 연산' 이라는 서로 다른 통화를 다루는 핵심 기능을 최대한 다른 객체로부터 분리시켜야 하기 때문인 듯하다. 다중 통화 연산을 지원하면서도 해당 코드는 다른 객체들에게 숨기고 싶은 것이다.



이에 대해  모든 currency를 하나의 참조통화(일종의 표준)으로 바꾸는 방안도 있을 수 있겠지만, 이 방식으로는 여러 환율을 계산하기가 어렵다. 대신에 편하게 환율을 표현하면서도, 산술 연산 표현을 그대로 가져갈 수 있는 수식 클래스를 새로 만드는 것이다.



이 Expression 클래스 객체는 결국에 Money 객체와 내부 구현은 다르지만, 외부적으로 드러나는 프로토콜, 형태는 같아야한다. 이를 저자는 **'imposter(사기꾼)'**이라고 말한다. Expression은 Money와 비슷하게 동작하지만, 사실은 두 Money의 합을 나타낸다.



#



```java
public void testSimplceAddition() {
  ...
  assertEquals(Money.dollar(10), reduced);
}
```



#

`reduced` 는 환율을 적용한 Expression이다.



여기서 켄트 백은 이해하기 약간 힘든 새로운 코드를 덧붙이는데, 다음과 같다.



#



```java
public void testSimplceAddition() {
  ...
  Money reduced = bank.reduce(sum, "USD");
  assertEquals(Money.dollar(10), reduced);
}
```



#



그냥 `...reduce = sum.reduce("USD", bank)` 라고 써, USD로 sum을 계산해 Expression 객체를 반환하는 코드를 만들 수도 있었을텐데, 굳이 `bank.reduce(sum, "USD")` 코드를 통해 bank가 `reduce()` 를 수행함을 명시했다.



Bank를 사용함으로써 Expression이라는 핵심 기능을 떼어내면 해당 객체는 최대한 유연해지고, 테스트하기 쉬워지고, 재활용하기 쉬워진다. OOP의 개념이 한껏 들어간 듯하다(이런 점을 보면 정말 java specific한 책이긴 하다). 학교 수업을 들어봤다면 좀 더 나았을텐데..



또, 추후 Expression 관련 오퍼레이션이 많아 질 것이 예상되므로, 모든 오퍼레이션을 Expression에 두지 않고 분산시킬 수 있게 된다.



이 시점에서 Bank를 사용하기로 한 것은 일시적인 판단으로, 추후에 이것이 필요없어지게 된다면 Expression으로 기능을 통합시킬 수도 있다. 일단 직관에 의해서 만들고, 추후에 정리해보자.



#



```java
public void testSimplceAddition() {
  Money five = Money.dollar(5);
  Expression sum = five.plus(five); // 두 Money의 합은 Expression이어야 한다.
  Bank bank = new Bank(); // Bank가 할 일은 정말 하나도 없다.
  Money reduced = bank.reduce(sum, "USD");
  assertEquals(Money.dollar(10), reduced);
}
```



#



Expression을 클래스로 만들어도 되지만, 오퍼레이션만을 담을 것이므로 더 가벼운 인터페이스로 만들기로 한다.



#



```java
interface Expresion
```

```java
Expression plus(Money addend) {
  return new Money(amount + addend.amount, currency);
}
```

```java
class Money implements Expression // Money가 Expression을 구현해야한다. 즉 Expression은 Money의 인터페이스이다.
```

```java
class Bank // 빈 클래스

Money reduce(Expression source, String to) { // reduce의 stub(dummy)
  return null;
}
```



#



컴파일이 되고, 실패한다. 빨강 막대를 보았으니 큰 진전이다. reduce를 간단히 가짜구현 해보자.



#



```java
Money reduce(Expression source, String to) {
  return Money.dollar(10);
}
```



---



# 13장 진짜로 만들기

#

> $5 + 10CHF = $10(환율이 2:1일 경우)
>
> **$5 + $5 = $10**



#



모든 중복을 제거하기 전에는 완료 표시를 할 수 없다. 코드 중복은 없지만, 데이터 중복을 제거하자.



```java
Money reduce(Expression source, String to) {
  return Money.dollar(10); 
}
```

```java
public void testSimplceAddition() {
  Money five = Money.dollar(5);
  Expression sum = five.plus(five);
  Bank bank = new Bank();
  Money reduced = bank.reduce(sum, "USD");
  assertEquals(Money.dollar(10), reduced);
}
```



#

`reduce()` stub의 return값에 있는 Money.dollar(10)는 사실 five.plus(five)와 같은 데이터이다. 이 데이터 중복을 어떻게 처리해야할까? 명확하지 않을 때는 일단 단계를 더 나누어 생각해 본다.



> $5 + 10CHF = $10(환율이 2:1일 경우)
>
> **$5 + $5 = $10**
>
> $5 + $5에서 Money 반환하기



`Money.plus()`는 Money가 아닌 `Expression(Sum)`을 반환해야 한다. 두 Money의 합은 sum이어야 할 것이다.

#



```java
public void testPlusReturnsSum() {
  Money five = Money.dollar(5);
  Expression result = five.plus(five);
  Sum sum = (Sum) result;
	assertEquals(five, sum.augend); // augend : 피가산수(덧셈의 첫 인자)
  assertEquals(Money.dollar(10), reduced);
}
```



#

위 테스트 코드 자체는 Expression을 Sum으로 만드는 등 내부 구현에 너무 깊게 관여한다는 문제점이 있다. 따라서 추후에 리팩토링 할 것이다. 일단 코드를 컴파일하기 위해 필요한 새로운 코드를 더 만들어주자.

#



```java
class Sum {
  Money augend;
  Money addend;
}
```



#

`Money.plus()`는 Sum이 아닌 Money를 반환하므로, 이 코드는 classCastException을 발생시킨다. 

따라서 다음 코드들로 수정한다.

#



```java
Expression plus(Money addend) {
  return new Sum(this, addend);
}
```



```java
// Sum 생성자
Sum(Money augend, Money addend) {
  this.augend = augend; // 비워두는 단계를 생략했다.
  this.addend = addend; // 비워두는 단계를 생략했다.
}

class Sum implements Expression // Sum은 Expression의 일종이어야 한다.
```



#

이제 정리해보자.

`Bank.reduce()` 는 Sum을 인자로 받는다 -> Sum이 가진 Money의 통화가 모두 동일하고, reduce를 통해 얻어내고자 하는 Money의 통화 역시 같음을 확인한다 -> `Bank.reduce()` 는 Sum 내의 Money들의 amount를 합친 amount 값을 가지는 Money객체를 반환한다.

#



```java
public void testReduceSum() {
  Expression sum = new Sum(Money.dollar(3), Money.dollar(4));
  Bank bank = new Bank();
  Money result = bank.reduce(sum, "USD");
  assertEquals(Money.dollar(7), result);
}
```



#



``` java
Money reduce(Expression source, String to) {
  Sum sum = (Sum) source;
  int amount = sum.augend.amount + sum.addend.amount;
  return new Money(amount, to);
}
```



위의 코드는 두가지 문제가 있다.

1. 타입캐스팅 : 모든 Expression에 대해 작동하지 않는다.
2. 몇몇 필드들이 pubic으로 설정되어 있고, 참조가 두번이나 일어났다(sum.augend.amount)



우선 2번 문제에서, 외부에서 접근 가능한 필드 몇개를 들어내기 위해 메서드 본문을 sum으로 옮길 수 있다. 추후에 Bank가 매개변수가 되어야 할 것 같지만...



#



```java
// Bank 코드
Money reduce(Expression source, String to) {
  Sum sum = (Sum) source;
  return sum.reduce(to);
}

// Sum 코드
public Money reduce(String to) {
  int amount = augend.amount + addend.amount;
  return new Money(amount, to);
}
```





> $5 + 10CHF = $10(환율이 2:1일 경우)
>
> **$5 + $5 = $10**
>
> $5 + $5에서 Money 반환하기
>
> Bank.reduce(Money) // Money을 넘겼을 경우에는 어떻게 테스트할 것인가?



#



일단 막대가 초록색이고 코드를 고칠 부분이 명확하지 않으니 테스트코드를 작성하자.



```java
public void testReduceMoney() {
  Bank bank = new Bank();
  Money result = bank.reduce(Money.dollar(1), "USD");
  assertEquals(Money.dollar(1), result);
}
```

```java
// Bank 코드
Money reduce(Expression source, String to) {
  if (source instanceof Money) return (Money) source;
  Sum sum = (Sum) source;
  return sum.reduce(to);
}
```



#

초록 막대 상태는 유지되고있다. 주의할 점은, 클래스를 명시하여 테스트하는 코드가 있을 경우 항상 다형성을 사용하도록 바꾸는 것이 좋다는 것이다. Sum의 `reduce(String)`을 Money가 구현하도록 만든다면, `reduce()` 는 Expression 인터페이스에도 추가할 수 있을 것이다.

#



```java
// Bank 코드
Money reduce(Expression source, String to) {
  if (source instanceof Money)
    return (Money) source.reduce(to);
  Sum sum = (Sum) source;
  return sum.reduce(to);
}

// Money 코드
public Money reduce(String to) {
  return this;
}
```



#

Expression 인터페이스에 `reduce(String)` 을 추가함으로써, Sum의 `reduce()`를 사용하기 위해 했던 지저분한 타입캐스팅, 그리고 source가 Money인지를 검사하는 클래스 검사 코드를 제거할 수 있다.

#



``` java
// Expression 인터페이스 코드
Money reduce(String to);
```

```java
// Bank 코드
Money reduce(Expression source, String to) {
  return source,reduce(to);
}
```



#

Expression과 Bank에 매개변수가 각각 다른, 그러나 동일한 이름의 메서드가 있다는 것은 불편한 사실이다. 자바에서는 키워드 매개변수를 지원하지 않으므로 매개인자가 무엇인지 정확히 표현할 수 없다(python은 arg1=a, arg2=b 형식으로 표현이 가능하다). 위치 매개변수만으로는 두 메서드의 차이를 코드에 담기 쉽지 않은 것이다.

#



> $5 + 10CHF = $10(환율이 2:1일 경우)
>
> **$5 + $5 = $10**
>
> $5 + $5에서 Money 반환하기
>
> ~~Bank.reduce(Money)~~
>
> Money에 대한 통화 변환을 수행하는 Reduce
>
> Reduce(Bank, String)

